<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Gear Simulator</title>
  <style>
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 1rem 2rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .title {
            font-size: 1.8rem;
            font-weight: bold;
            color: #333;
            margin: 0;
        }

        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
        }

        .btn-primary {
            background: #4f46e5;
            color: white;
        }

        .btn-primary:hover {
            background: #4338ca;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
        }

        .btn-secondary:hover {
            background: #4b5563;
            transform: translateY(-2px);
        }

        .workspace {
            flex: 1;
            position: relative;
            background: rgba(255, 255, 255, 0.1);
            margin: 1rem;
            border-radius: 12px;
            overflow: hidden;
            min-height: 500px;
            cursor: grab;
        }

        .workspace.panning {
            cursor: grabbing;
        }

        .workspace-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
        }

        .zoom-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 1000;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }

        .zoom-btn:hover {
            background: white;
            transform: scale(1.1);
        }

        .zoom-level {
            background: rgba(255, 255, 255, 0.9);
            padding: 0.5rem;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            min-width: 60px;
        }

        .gear {
            position: absolute;
            cursor: move;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .gear-circle {
            border-radius: 50%;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #333;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            position: relative;
            border: 3px solid #333;
        }

        .gear-circle.rotating {
            animation: rotate 2s linear infinite;
        }

        .gear-circle.rotating-reverse {
            animation: rotate-reverse 2s linear infinite;
        }

        .gear-teeth.rotating {
            animation: rotate 2s linear infinite;
        }

        .gear-teeth.rotating-reverse {
            animation: rotate-reverse 2s linear infinite;
        }

        .rotation-arrow {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 15;
        }

        .rotation-arrow.rotating {
            animation: rotate 2s linear infinite;
        }

        .rotation-arrow.rotating-reverse {
            animation: rotate-reverse 2s linear infinite;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes rotate-reverse {
            from { transform: rotate(0deg); }
            to { transform: rotate(-360deg); }
        }

        @keyframes jamPulseBadge {
            0%, 100% { transform: scale(1); }
            50%      { transform: scale(1.05); }
        }

        .gear-teeth {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .gear-label {
            position: relative;
            z-index: 10;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        }

        .gear-info {
            background: rgba(255, 255, 255, 0.95);
            padding: 0.5rem;
            border-radius: 8px;
            text-align: center;
            font-size: 0.8rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            min-width: 120px;
            position: absolute;
            cursor: move;
            border: 2px solid #4f46e5;
            z-index: 100;
        }

        .compound-gear {
            border-color: #f59e0b !important;
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.4), 0 4px 15px rgba(0, 0, 0, 0.3) !important;
        }

        .info-pointer {
            position: absolute;
            height: 2px;
            background: #4f46e5;
            transform-origin: left center;
            z-index: -1;
            pointer-events: none;
        }

        .gear-controls {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.25rem;
            justify-content: center;
        }

        .size-btn {
            padding: 0.25rem 0.5rem;
            border: none;
            border-radius: 4px;
            background: #6366f1;
            color: white;
            cursor: pointer;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .size-btn:hover {
            background: #4f46e5;
        }

        .size-btn:active {
            transform: scale(0.95);
        }

        .connection-line {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
            transform-origin: left center;
            z-index: 1;
            border-radius: 2px;
        }

        .chain-connection {
            position: absolute;
            height: 12px;
            transform-origin: left center;
            z-index: 2;
            pointer-events: none;
        }

        .chain-segment {
            position: absolute;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                transparent 0px,
                transparent 2px,
                #4a5568 2px,
                #4a5568 4px,
                #2d3748 4px,
                #2d3748 6px,
                #4a5568 6px,
                #4a5568 8px,
                transparent 8px,
                transparent 10px
            );
            border-radius: 0;
            border: none;
            overflow: hidden;
        }

        .chain-segment::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(ellipse 4px 6px at 5px 50%, #718096 0%, #4a5568 50%, #2d3748 100%),
                radial-gradient(ellipse 4px 6px at 15px 50%, #718096 0%, #4a5568 50%, #2d3748 100%),
                radial-gradient(ellipse 4px 6px at 25px 50%, #718096 0%, #4a5568 50%, #2d3748 100%),
                radial-gradient(ellipse 4px 6px at 35px 50%, #718096 0%, #4a5568 50%, #2d3748 100%);
            background-repeat: repeat-x;
            background-size: 20px 100%;
            background-position: var(--before-position, 0px 0px);
            transition: background-position 0.1s linear;
        }

        .chain-segment::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(ellipse 4px 6px at 10px 50%, #8a8a8a 0%, #5a5a5a 50%, #3a3a3a 100%),
                radial-gradient(ellipse 4px 6px at 30px 50%, #8a8a8a 0%, #5a5a5a 50%, #3a3a3a 100%);
            background-repeat: repeat-x;
            background-size: 20px 100%;
            background-position: var(--after-position, 0px 0px);
            opacity: 0.8;
            transition: background-position 0.1s linear;
        }

        .chain-mode {
            background: #f59e0b !important;
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.5) !important;
        }

        .chain-preview {
            position: absolute;
            height: 12px;
            transform-origin: left center;
            z-index: 10;
            opacity: 0.8;
            pointer-events: none;
        }

        .chain-preview-segment {
            position: absolute;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                transparent 0px,
                transparent 2px,
                #d97706 2px,
                #d97706 4px,
                #92400e 4px,
                #92400e 6px,
                #d97706 6px,
                #d97706 8px,
                transparent 8px,
                transparent 10px
            );
            border-radius: 0;
            border: none;
            overflow: hidden;
        }

        .chain-preview-segment::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(ellipse 4px 6px at 5px 50%, #f59e0b 0%, #d97706 50%, #92400e 100%),
                radial-gradient(ellipse 4px 6px at 15px 50%, #f59e0b 0%, #d97706 50%, #92400e 100%),
                radial-gradient(ellipse 4px 6px at 25px 50%, #f59e0b 0%, #d97706 50%, #92400e 100%),
                radial-gradient(ellipse 4px 6px at 35px 50%, #f59e0b 0%, #d97706 50%, #92400e 100%);
            background-repeat: repeat-x;
            background-size: 20px 100%;
            background-position: 0 0;
        }

        .chain-preview-segment::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(ellipse 4px 6px at 10px 50%, #fbbf24 0%, #f59e0b 50%, #d97706 100%),
                radial-gradient(ellipse 4px 6px at 30px 50%, #fbbf24 0%, #f59e0b 50%, #d97706 100%);
            background-repeat: repeat-x;
            background-size: 20px 100%;
            background-position: 0 0;
            opacity: 0.9;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 1rem;
            margin: 1rem;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .info-card {
            background: #f8fafc;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #4f46e5;
        }

        .warning-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            text-align: center;
            border: 3px solid #ef4444;
            max-width: 400px;
            width: 90%;
        }

        .warning-popup h3 {
            color: #ef4444;
            margin: 0 0 1rem 0;
            font-size: 1.2rem;
        }

        .warning-popup p {
            margin: 0 0 1.5rem 0;
            color: #666;
            line-height: 1.5;
        }

        .warning-popup button {
            background: #ef4444;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .warning-popup button:hover {
            background: #dc2626;
        }

        .confirmation-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            text-align: center;
            border: 3px solid #6b7280;
            max-width: 400px;
            width: 90%;
        }

        .confirmation-popup h3 {
            color: #374151;
            margin: 0 0 1rem 0;
            font-size: 1.2rem;
        }

        .confirmation-popup p {
            margin: 0 0 1.5rem 0;
            color: #6b7280;
            line-height: 1.5;
        }

        .confirmation-popup .button-group {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .confirmation-popup button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .confirmation-popup .btn-confirm {
            background: #6b7280;
            color: white;
        }

        .confirmation-popup .btn-confirm:hover {
            background: #4b5563;
        }

        .confirmation-popup .btn-cancel {
            background: #e5e7eb;
            color: #374151;
        }

        .confirmation-popup .btn-cancel:hover {
            background: #d1d5db;
        }

        .examples-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            max-width: 500px;
            width: 90%;
            max-height: 70vh;
            overflow-y: auto;
        }

        .examples-popup h3 {
            color: #374151;
            margin: 0 0 1.5rem 0;
            font-size: 1.3rem;
            text-align: center;
        }

        .examples-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .example-item {
            padding: 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f9fafb;
        }

        .example-item:hover {
            border-color: #4f46e5;
            background: #f0f9ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.15);
        }

        .example-title {
            font-weight: bold;
            color: #374151;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        .example-description {
            color: #6b7280;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .examples-popup .close-btn {
            background: #6b7280;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s ease;
            width: 100%;
        }

        .examples-popup .close-btn:hover {
            background: #4b5563;
        }

        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
        }

        .info-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 0.5rem;
        }

        .motor-gear {
            border-color: #ef4444 !important;
            background: linear-gradient(45deg, #ff6b6b, #ff8e8e) !important;
        }

        .pinned-gear {
            border-color: #8b5cf6 !important;
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.5), 0 4px 15px rgba(0, 0, 0, 0.3) !important;
        }

        .ring-gear {
            background: transparent !important;
            border: none !important;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4) !important;
        }

        .ring-gear .gear-circle {
            background: transparent !important;
            border: none !important;
        }

        .ring-gear .gear-label {
            background: rgba(6, 95, 70, 0.95);
            color: white;
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            font-size: 11px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .snap-indicator {
            position: absolute;
            border: 3px dashed #10b981;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            opacity: 0.7;
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                text-align: center;
            }

            .controls {
                justify-content: center;
            }

            .workspace {
                margin: 0.5rem;
                min-height: 400px;
            }

            .info-panel {
                margin: 0.5rem;
            }
        }
    </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="/_sdk/element_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body>
  <div class="header">
   <h1 class="title">‚öôÔ∏è Interactive Gear Simulator</h1>
   <div class="controls"><button class="btn btn-secondary" id="backToHubBtn" onclick="showBackToHubConfirmation()">‚Üê Back to Hub</button> <button class="btn btn-primary" id="addGearBtn" onclick="addGear()">Add Gear</button> <button class="btn btn-primary" id="addRingGearBtn" onclick="addRingGear()">Add Ring Gear</button> <button class="btn btn-primary" id="addChainBtn" onclick="toggleChainMode()">üîó Add Chain</button> <button class="btn btn-primary" id="addLayerBtn" onclick="addLayer()">New Layer</button> <button class="btn btn-danger" id="removeLayerBtn" onclick="removeCurrentLayer()">Remove Layer</button> <button class="btn btn-primary" onclick="saveGearSetup()">üíæ Save Setup</button> <button class="btn btn-primary" onclick="loadGearSetup()">üìÅ Load Setup</button> <button class="btn btn-primary" onclick="showExamplesMenu()">üìö Load Examples</button> <button class="btn btn-danger" id="clearBtn" onclick="clearWorkspace()">Clear All</button> <button class="btn btn-primary" onclick="toggleAnimation()">Start/Stop</button>
    <div style="display: flex; align-items: center; gap: 0.5rem; background: rgba(255,255,255,0.9); padding: 0.5rem 1rem; border-radius: 8px;"><label style="font-weight: 600; color: #333;">Motor RPM:</label> <input type="range" id="rpmSlider" min="1" max="300" value="120" style="width: 120px;" oninput="updateMotorRPM(this.value)"> <span id="rpmValue" style="font-weight: bold; color: #4f46e5; min-width: 40px;">120</span>
    </div>
    <div style="display: flex; align-items: center; gap: 0.5rem; background: rgba(255,255,255,0.9); padding: 0.5rem 1rem; border-radius: 8px;"><label style="font-weight: 600; color: #333;">Layer:</label> <select id="layerSelect" onchange="switchLayer(this.value)" style="padding: 0.25rem; border-radius: 4px; border: 1px solid #ccc; font-weight: bold;"> <option value="0">Layer 0</option> </select>
    </div><button class="btn btn-primary" onclick="toggleDebugPanel()">üîç Debug</button>
   </div>
  </div>
  <div class="workspace" id="workspace">
   <div class="workspace-content" id="workspaceContent"></div>
   <div class="zoom-controls"><button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
    <div class="zoom-level" id="zoomLevel">
     100%
    </div><button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">‚àí</button> <button class="zoom-btn" onclick="resetView()" title="Reset View">üè†</button>
   </div>
  </div>
  <div class="info-panel">
   <div class="info-title">
    Gear Physics Concepts
   </div>
   <div class="info-grid">
    <div class="info-card">
     <div class="info-title">
      Motor Gear
     </div>
     <div>
      Red gear provides power to the system<br>
      Click any gear's M button to make it the motor
     </div>
    </div>
    <div class="info-card">
     <div class="info-title">
      Ring Gears
     </div>
     <div>
      Green hollow gears with internal teeth<br>
      Automatically snap to proper meshing position
     </div>
    </div>
    <div class="info-card">
     <div class="info-title">
      Pinned Gears
     </div>
     <div>
      Purple gears are fixed in place<br>
      Create planetary systems by pinning gears
     </div>
    </div>
    <div class="info-card">
     <div class="info-title">
      Compound Gears
     </div>
     <div>
      Orange gears have two sizes on one shaft<br>
      Click 'C' button to add inner gear
     </div>
    </div>
    <div class="info-card">
     <div class="info-title">
      Layer System
     </div>
     <div>
      Switch layers to organize gears in 3D space<br>
      Gears on other layers appear translucent
     </div>
    </div>
    <div class="info-card">
     <div class="info-title">
      Chain Connections
     </div>
     <div>
      Click üîó Add Chain, then click two gears to connect<br>
      Chains maintain same rotation direction over distance
     </div>
    </div>
    <div class="info-card">
     <div class="info-title">
      Gear Ratios
     </div>
     <div>
      Speed = Motor RPM √ó (Motor Teeth √∑ Gear Teeth)<br>
      Larger gears spin slower but with more torque
     </div>
    </div>
   </div>
  </div>
  <div id="debugPanel" class="info-panel" style="margin-top: 1rem; display: none;">
   <div class="info-title">
    üîç Debug Panel
   </div>
   <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem;">
    <div class="info-card">
     <div class="info-title">
      Gears in Array
     </div>
     <div id="debugGears" style="font-family: monospace; font-size: 0.8rem; max-height: 200px; overflow-y: auto;"></div>
    </div>
    <div class="info-card">
     <div class="info-title">
      Info Boxes Status
     </div>
     <div id="debugInfos" style="font-family: monospace; font-size: 0.8rem; max-height: 200px; overflow-y: auto;"></div>
    </div>
    <div class="info-card">
     <div class="info-title">
      Chain Connections
     </div>
     <div id="debugChains" style="font-family: monospace; font-size: 0.8rem; max-height: 200px; overflow-y: auto;"></div>
    </div>
   </div>
   <div style="margin-top: 1rem; text-align: center;"><button class="btn btn-primary" onclick="updateDebugInfo()">Refresh Debug Info</button>
   </div>
  </div>
  <script>
        let gears = [];
        let gearCounter = 0;
        let isAnimating = false;
        let draggedGear = null;
        let draggedInfo = null;
        let dragOffset = { x: 0, y: 0 };
        
        // Chain system
        let chains = [];
        let chainCounter = 0;
        let isChainMode = false;
        let chainStartGear = null;
        let chainPreview = null;
        
        // Layer system
        let currentLayer = 0;
        let layers = [0]; // Available layers
        let maxLayer = 0;

        // Camera system
        let cameraX = 0;
        let cameraY = 0;
        let cameraZoom = 1;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let panOffset = { x: 0, y: 0 };

        class Chain {
            constructor(gear1, gear2) {
                this.id = ++chainCounter;
                this.gear1 = gear1;
                this.gear2 = gear2;
                this.element = this.createElement();
                this.updatePosition();
            }

            createElement() {
                const chainDiv = document.createElement('div');
                chainDiv.className = 'chain-connection';
                
                // Create the visual chain segment
                const chainSegment = document.createElement('div');
                chainSegment.className = 'chain-segment';
                chainDiv.appendChild(chainSegment);
                
                return chainDiv;
            }

            updatePosition() {
                if (!this.gear1.element || !this.gear2.element) return;
                
                // Clear existing chain segments
                this.element.innerHTML = '';
                
                // Get gear centers and radii
                const center1 = { x: this.gear1.getCenterX(), y: this.gear1.getCenterY() };
                const center2 = { x: this.gear2.getCenterX(), y: this.gear2.getCenterY() };
                const radius1 = this.gear1.getRadius();
                const radius2 = this.gear2.getRadius();
                
                // Calculate the angle between gear centers
                const dx = center2.x - center1.x;
                const dy = center2.y - center1.y;
                const centerDistance = Math.sqrt(dx * dx + dy * dy);
                const centerAngle = Math.atan2(dy, dx);
                
                // Calculate external tangent points for proper chain wrapping
                let tangentAngle1, tangentAngle2;
                
                if (Math.abs(radius1 - radius2) < centerDistance) {
                    // External tangent case (most common)
                    const radiusDiff = radius2 - radius1;
                    const tangentOffset = Math.asin(radiusDiff / centerDistance);
                    
                    tangentAngle1 = centerAngle + Math.PI/2 + tangentOffset;
                    tangentAngle2 = centerAngle - Math.PI/2 + tangentOffset; // Fixed: opposite side for gear2
                } else {
                    // Gears are too close or overlapping - use simple connection
                    tangentAngle1 = centerAngle;
                    tangentAngle2 = centerAngle + Math.PI; // Fixed: opposite side for gear2
                }
                
                // Calculate tangent points on gear circumferences
                const tangent1 = {
                    x: center1.x + radius1 * Math.cos(tangentAngle1),
                    y: center1.y + radius1 * Math.sin(tangentAngle1)
                };
                
                const tangent2 = {
                    x: center2.x + radius2 * Math.cos(tangentAngle2),
                    y: center2.y + radius2 * Math.sin(tangentAngle2)
                };
                
                // Create chain segments for the complete path
                this.createChainPath(center1, center2, radius1, radius2, tangent1, tangent2, tangentAngle1, tangentAngle2);
            }
            
            createChainPath(center1, center2, radius1, radius2, tangent1, tangent2, tangentAngle1, tangentAngle2) {
                // Calculate the angle between gear centers
                const dx = center2.x - center1.x;
                const dy = center2.y - center1.y;
                const centerAngle = Math.atan2(dy, dx);
                
                // Calculate external tangent points for proper chain connection
                const perpAngle = centerAngle + Math.PI/2;
                
                // Top chain segment
                const topPoint1 = {
                    x: center1.x + radius1 * Math.cos(perpAngle),
                    y: center1.y + radius1 * Math.sin(perpAngle)
                };
                const topPoint2 = {
                    x: center2.x + radius2 * Math.cos(perpAngle),
                    y: center2.y + radius2 * Math.sin(perpAngle)
                };
                
                // Bottom chain segment
                const bottomPoint1 = {
                    x: center1.x + radius1 * Math.cos(perpAngle + Math.PI),
                    y: center1.y + radius1 * Math.sin(perpAngle + Math.PI)
                };
                const bottomPoint2 = {
                    x: center2.x + radius2 * Math.cos(perpAngle + Math.PI),
                    y: center2.y + radius2 * Math.sin(perpAngle + Math.PI)
                };
                
                // Create the two straight chain segments
                this.createStraightSegment(topPoint1, topPoint2, 'top-straight');
                this.createStraightSegment(bottomPoint1, bottomPoint2, 'bottom-straight');
                
                // Create arc segments around each gear (half circles)
                this.createArcSegment(center1, radius1, perpAngle, perpAngle + Math.PI, 1);
                this.createArcSegment(center2, radius2, perpAngle + Math.PI, perpAngle + 2 * Math.PI, 2);
            }
            
            createStraightSegment(point1, point2, segmentType = 'straight') {
                const segment = document.createElement('div');
                segment.className = 'chain-segment';
                
                const length = Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
                const angle = Math.atan2(point2.y - point1.y, point2.x - point1.x) * 180 / Math.PI;
                
                segment.style.position = 'absolute';
                segment.style.left = point1.x + 'px';
                segment.style.top = (point1.y - 6) + 'px';
                segment.style.width = length + 'px';
                segment.style.height = '12px';
                segment.style.transform = `rotate(${angle}deg)`;
                segment.style.transformOrigin = 'left center';
                
                // Store segment type and direction for animation
                segment.setAttribute('data-segment-type', segmentType);
                segment.setAttribute('data-angle', angle);
                
                this.element.appendChild(segment);
            }
            
            createArcSegment(center, radius, startAngle, endAngle, gearIndex) {
                // Create arc segments around half of each gear
                const numSegments = 16; // Fixed number for smooth half-circle
                const angleStep = (endAngle - startAngle) / numSegments;
                
                for (let i = 0; i < numSegments; i++) {
                    const angle1 = startAngle + i * angleStep;
                    const angle2 = startAngle + (i + 1) * angleStep;
                    
                    const point1 = {
                        x: center.x + radius * Math.cos(angle1),
                        y: center.y + radius * Math.sin(angle1)
                    };
                    const point2 = {
                        x: center.x + radius * Math.cos(angle2),
                        y: center.y + radius * Math.sin(angle2)
                    };
                    
                    this.createStraightSegment(point1, point2, `arc-gear${gearIndex}`);
                }
            }

            startAnimation() {
                // Calculate chain speed based on connected gears
                const gear1Speed = Math.abs(this.gear1.rpm);
                const gear2Speed = Math.abs(this.gear2.rpm);
                const averageSpeed = (gear1Speed + gear2Speed) / 2;
                
                // Calculate animation duration - faster gears = faster chain
                // Base duration of 2 seconds at 60 RPM, scale inversely with speed
                const baseDuration = 2; // seconds
                const baseRPM = 60;
                const duration = averageSpeed > 0 ? (baseDuration * baseRPM / averageSpeed) : baseDuration;
                
                // Apply animation to all chain segments
                const chainSegments = this.element.querySelectorAll('.chain-segment');
                chainSegments.forEach(segment => {
                    segment.style.setProperty('--chain-duration', `${Math.max(0.1, duration)}s`);
                    segment.classList.add('animating');
                });
            }

            stopAnimation() {
                const chainSegments = this.element.querySelectorAll('.chain-segment');
                chainSegments.forEach(segment => {
                    segment.classList.remove('animating');
                });
            }

            remove() {
                if (this.element && this.element.parentNode) {
                    this.element.remove();
                }
                
                // Remove chain references from gears
                if (this.gear1.chainConnections) {
                    this.gear1.chainConnections = this.gear1.chainConnections.filter(c => c !== this);
                }
                if (this.gear2.chainConnections) {
                    this.gear2.chainConnections = this.gear2.chainConnections.filter(c => c !== this);
                }
            }

            isValid() {
                // Check if both gears still exist
                return gears.includes(this.gear1) && gears.includes(this.gear2);
            }
        }

        class Gear {
            constructor(x, y, size = 80, isRingGear = false, parentGear = null, layer = null) {
                this.id = ++gearCounter;
                this.x = x;
                this.y = y;
                this.size = size;
                this.isRingGear = isRingGear;
                this.teeth = this.calculateTeeth();
                this.rpm = 0;
                this.torque = 100;
                this.isMotor = this.id === 1 && !isRingGear; // First regular gear is motor
                this.isPinned = false;
                this.connectedGears = [];
                this.infoX = x + size + 20;
                this.infoY = y;
                this.rotationDirection = 'normal';
                this.parentGear = parentGear;
                this.compoundGear = null;
                this.chainConnections = [];
                this.layer = layer !== null ? layer : (parentGear ? parentGear.layer + 1 : currentLayer);
                this.element = this.createElement();
                this.updateDisplay();
                this.updateLayerVisibility();
            }

            calculateTeeth() {
                if (this.isRingGear) {
                    // Ring gears have more teeth due to larger circumference
                    return Math.floor(this.size / 1.8) + 20;
                } else {
                    // Regular gears
                    return Math.floor(this.size / 2.4) + 8;
                }
            }

            getRadius() {
                return this.size / 2;
            }

            getInnerRadius() {
                if (this.isRingGear) {
                    return this.getRadius() - 35; // Large center gap for ring gears
                } else {
                    return this.getRadius();
                }
            }

            getCenterX() {
                return this.x + this.getRadius();
            }

            getCenterY() {
                return this.y + this.getRadius();
            }

            createElement() {
                const gearDiv = document.createElement('div');
                gearDiv.className = 'gear';
                gearDiv.style.left = this.x + 'px';
                gearDiv.style.top = this.y + 'px';

                const circle = document.createElement('div');
                circle.className = `gear-circle ${this.isMotor ? 'motor-gear' : ''} ${this.isPinned ? 'pinned-gear' : ''} ${this.isRingGear ? 'ring-gear' : ''} ${this.compoundGear || this.parentGear ? 'compound-gear' : ''}`;
                circle.style.width = this.size + 'px';
                circle.style.height = this.size + 'px';
                
                // Create gear teeth using SVG
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('class', 'gear-teeth');
                svg.setAttribute('viewBox', `0 0 ${this.size} ${this.size}`);
                svg.style.position = 'absolute';
                svg.style.width = '100%';
                svg.style.height = '100%';
                svg.style.top = '0';
                svg.style.left = '0';
                
                this.createGearTeeth(svg);
                circle.appendChild(svg);
                
                // Create rotation arrow container
                const arrowSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                arrowSvg.setAttribute('class', 'rotation-arrow');
                arrowSvg.setAttribute('viewBox', `0 0 ${this.size} ${this.size}`);
                arrowSvg.style.position = 'absolute';
                arrowSvg.style.width = '100%';
                arrowSvg.style.height = '100%';
                arrowSvg.style.top = '0';
                arrowSvg.style.left = '0';
                
                circle.appendChild(arrowSvg);

                gearDiv.appendChild(circle);

                // Only create info box for outer gears (not inner compound gears)
                if (!this.parentGear) {
                    const info = document.createElement('div');
                    info.className = 'gear-info';
                    info.style.left = (this.size + 20) + 'px';
                    info.style.top = '0px';
                    // Add data attribute to track which gear this info belongs to
                    info.setAttribute('data-gear-id', this.id);
                    if (this.compoundGear) {
                        info.setAttribute('data-compound-id', this.compoundGear.id);
                    }
                    
                    // Create pointer line
                    const pointer = document.createElement('div');
                    pointer.className = 'info-pointer';
                    
                    gearDiv.appendChild(info);
                    gearDiv.appendChild(pointer);

                    // Add drag functionality for info
                    info.addEventListener('mousedown', (e) => this.startInfoDrag(e));
                    info.addEventListener('touchstart', (e) => this.startInfoDrag(e));
                }

                // Add drag functionality for gear
                circle.addEventListener('mousedown', (e) => this.startDrag(e));
                circle.addEventListener('touchstart', (e) => this.startDrag(e));
                
                // Add click functionality for chain mode
                circle.addEventListener('click', (e) => this.handleClick(e));

                return gearDiv;
            }

            createGearTeeth(svg) {
                const centerX = this.size / 2;
                const centerY = this.size / 2;
                
                if (this.isRingGear) {
                    // Create the main ring body first
                    const outerRadius = this.getRadius() - 3;
                    const innerRadius = this.getInnerRadius();
                    
                    // Main ring body
                    const ringPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const pathData = `M ${centerX - outerRadius} ${centerY} 
                                     A ${outerRadius} ${outerRadius} 0 1 1 ${centerX + outerRadius} ${centerY}
                                     A ${outerRadius} ${outerRadius} 0 1 1 ${centerX - outerRadius} ${centerY}
                                     M ${centerX - innerRadius} ${centerY}
                                     A ${innerRadius} ${innerRadius} 0 1 0 ${centerX + innerRadius} ${centerY}
                                     A ${innerRadius} ${innerRadius} 0 1 0 ${centerX - innerRadius} ${centerY}`;
                    ringPath.setAttribute('d', pathData);
                    ringPath.setAttribute('fill', '#10b981');
                    ringPath.setAttribute('fill-rule', 'evenodd');
                    ringPath.setAttribute('stroke', '#065f46');
                    ringPath.setAttribute('stroke-width', '2');
                    svg.appendChild(ringPath);
                    
                    // Create internal teeth
                    const teethRadius = innerRadius + 12;
                    const actualTeeth = Math.max(16, Math.floor(this.teeth * 0.8));
                    
                    for (let i = 0; i < actualTeeth; i++) {
                        const angle = (i / actualTeeth) * 2 * Math.PI;
                        const toothWidth = (2 * Math.PI) / actualTeeth * 0.5;
                        
                        // Create rectangular teeth pointing inward
                        const angle1 = angle - toothWidth / 2;
                        const angle2 = angle + toothWidth / 2;
                        
                        const x1 = centerX + innerRadius * Math.cos(angle1);
                        const y1 = centerY + innerRadius * Math.sin(angle1);
                        const x2 = centerX + innerRadius * Math.cos(angle2);
                        const y2 = centerY + innerRadius * Math.sin(angle2);
                        const x3 = centerX + teethRadius * Math.cos(angle2);
                        const y3 = centerY + teethRadius * Math.sin(angle2);
                        const x4 = centerX + teethRadius * Math.cos(angle1);
                        const y4 = centerY + teethRadius * Math.sin(angle1);
                        
                        const tooth = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        tooth.setAttribute('points', `${x1},${y1} ${x2},${y2} ${x3},${y3} ${x4},${y4}`);
                        tooth.setAttribute('fill', '#065f46');
                        tooth.setAttribute('stroke', '#047857');
                        tooth.setAttribute('stroke-width', '0.5');
                        svg.appendChild(tooth);
                    }
                    
                    // Add inner decorative circle
                    const innerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    innerCircle.setAttribute('cx', centerX);
                    innerCircle.setAttribute('cy', centerY);
                    innerCircle.setAttribute('r', innerRadius - 2);
                    innerCircle.setAttribute('fill', 'none');
                    innerCircle.setAttribute('stroke', '#10b981');
                    innerCircle.setAttribute('stroke-width', '1');
                    innerCircle.setAttribute('stroke-dasharray', '5,3');
                    innerCircle.setAttribute('opacity', '0.7');
                    svg.appendChild(innerCircle);
                    
                } else {
                    // Regular gear has external teeth - keep existing design
                    const innerRadius = this.getRadius() - 8;
                    const outerRadius = this.getRadius() - 2;
                    
                    let pathData = '';
                    const actualTeeth = Math.max(8, this.teeth);
                    
                    for (let i = 0; i < actualTeeth; i++) {
                        const angle1 = (i / actualTeeth) * 2 * Math.PI;
                        const angle2 = ((i + 0.3) / actualTeeth) * 2 * Math.PI;
                        const angle3 = ((i + 0.7) / actualTeeth) * 2 * Math.PI;
                        const angle4 = ((i + 1) / actualTeeth) * 2 * Math.PI;
                        
                        const x1 = centerX + innerRadius * Math.cos(angle1);
                        const y1 = centerY + innerRadius * Math.sin(angle1);
                        const x2 = centerX + outerRadius * Math.cos(angle2);
                        const y2 = centerY + outerRadius * Math.sin(angle2);
                        const x3 = centerX + outerRadius * Math.cos(angle3);
                        const y3 = centerY + outerRadius * Math.sin(angle3);
                        const x4 = centerX + innerRadius * Math.cos(angle4);
                        const y4 = centerY + innerRadius * Math.sin(angle4);
                        
                        if (i === 0) {
                            pathData += `M ${x1} ${y1}`;
                        }
                        pathData += ` L ${x2} ${y2} L ${x3} ${y3} L ${x4} ${y4}`;
                    }
                    pathData += ' Z';
                    
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', pathData);
                    path.setAttribute('fill', '#333');
                    path.setAttribute('stroke', '#222');
                    path.setAttribute('stroke-width', '1');
                    
                    svg.appendChild(path);
                }
            }

            createRotationArrow(svg) {
                if (this.rpm === 0) return;
                
                const centerX = this.size / 2;
                const centerY = this.size / 2;
                const radius = this.isRingGear ? this.getInnerRadius() + 10 : (this.size / 2) - 20;
                
                let startAngle, endAngle, sweepFlag;
                
                if (this.rotationDirection === 'reverse') {
                    startAngle = Math.PI / 3;
                    endAngle = -Math.PI / 3;
                    sweepFlag = 0;
                } else {
                    startAngle = -Math.PI / 3;
                    endAngle = Math.PI / 3;
                    sweepFlag = 1;
                }
                
                const startX = centerX + radius * Math.cos(startAngle);
                const startY = centerY + radius * Math.sin(startAngle);
                const endX = centerX + radius * Math.cos(endAngle);
                const endY = centerY + radius * Math.sin(endAngle);
                
                const pathData = `M ${startX} ${startY} A ${radius} ${radius} 0 0 ${sweepFlag} ${endX} ${endY}`;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', pathData);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', this.isRingGear ? '#ffffff' : '#ff4444');
                path.setAttribute('stroke-width', '3');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('marker-end', 'url(#arrowhead-' + this.id + ')');
                
                const arrowScale = this.teeth / 108;
                const arrowWidth = Math.max(4, Math.min(12, 6 * arrowScale));
                const arrowHeight = Math.max(2.5, Math.min(8, 4 * arrowScale));
                
                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', 'arrowhead-' + this.id);
                marker.setAttribute('markerWidth', arrowWidth.toString());
                marker.setAttribute('markerHeight', arrowHeight.toString());
                marker.setAttribute('refX', (arrowWidth - 1).toString());
                marker.setAttribute('refY', (arrowHeight / 2).toString());
                marker.setAttribute('orient', 'auto');
                
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', `0 0, ${arrowWidth} ${arrowHeight/2}, 0 ${arrowHeight}`);
                polygon.setAttribute('fill', this.isRingGear ? '#ffffff' : '#ff4444');
                
                marker.appendChild(polygon);
                defs.appendChild(marker);
                svg.appendChild(defs);
                svg.appendChild(path);
            }

            handleClick(e) {
                if (isChainMode && !draggedGear) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Don't allow chain connections to gears not on current layer
                    if (currentLayer !== 'all' && this.layer !== currentLayer) {
                        return;
                    }
                    
                    if (!chainStartGear) {
                        // First gear selected
                        chainStartGear = this;
                        this.element.querySelector('.gear-circle').classList.add('chain-mode');
                        showSuccessMessage("First gear selected! Click another gear to create chain.");
                    } else if (chainStartGear === this) {
                        // Clicked same gear - cancel
                        chainStartGear.element.querySelector('.gear-circle').classList.remove('chain-mode');
                        chainStartGear = null;
                        clearChainPreview();
                        showSuccessMessage("Chain selection cancelled.");
                    } else {
                        // Second gear selected - create chain
                        createChain(chainStartGear, this);
                        chainStartGear.element.querySelector('.gear-circle').classList.remove('chain-mode');
                        chainStartGear = null;
                        clearChainPreview();
                    }
                }
            }

            startDrag(e) {
                // Don't allow dragging gears not on current layer (unless showing all layers)
                if (currentLayer !== 'all' && this.layer !== currentLayer) {
                    return;
                }
                
                // Don't start drag if in chain mode and clicking
                if (isChainMode) {
                    return;
                }
                
                e.preventDefault();
                e.stopPropagation();
                draggedGear = this;
                const workspace = document.getElementById('workspace');
                const workspaceRect = workspace.getBoundingClientRect();
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                // Convert to workspace coordinates
                const workspaceX = (clientX - workspaceRect.left - cameraX) / cameraZoom;
                const workspaceY = (clientY - workspaceRect.top - cameraY) / cameraZoom;
                
                dragOffset.x = workspaceX - this.x;
                dragOffset.y = workspaceY - this.y;
            }

            startInfoDrag(e) {
                e.preventDefault();
                e.stopPropagation();
                draggedInfo = this;
                const info = this.element.querySelector('.gear-info');
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                dragOffset.x = clientX - (this.x + parseFloat(info.style.left));
                dragOffset.y = clientY - (this.y + parseFloat(info.style.top));
            }

            updatePosition(x, y) {
                this.x = x;
                this.y = y;
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
                
                // Bring this gear to the front
                this.bringToFront();
                
                // Update compound gear position if it exists (even if on different layer)
                if (this.compoundGear) {
                    const centerOffsetX = (this.size - this.compoundGear.size) / 2;
                    const centerOffsetY = (this.size - this.compoundGear.size) / 2;
                    this.compoundGear.x = x + centerOffsetX;
                    this.compoundGear.y = y + centerOffsetY;
                    this.compoundGear.element.style.left = this.compoundGear.x + 'px';
                    this.compoundGear.element.style.top = this.compoundGear.y + 'px';
                    this.compoundGear.bringToFront();
                }
                
                // Update parent gear position if this is a compound gear (even if on different layer)
                if (this.parentGear) {
                    const centerOffsetX = (this.parentGear.size - this.size) / 2;
                    const centerOffsetY = (this.parentGear.size - this.size) / 2;
                    this.parentGear.x = x - centerOffsetX;
                    this.parentGear.y = y - centerOffsetY;
                    this.parentGear.element.style.left = this.parentGear.x + 'px';
                    this.parentGear.element.style.top = this.parentGear.y + 'px';
                    this.parentGear.bringToFront();
                }
                
                this.findConnections();
                calculateGearPhysics();
                drawConnections();
                updateChainPositions();
            }

            updateCompoundLayering() {
                if (this.compoundGear) {
                    // Outer gear always goes behind, inner gear always goes in front
                    this.element.style.zIndex = '10';
                    this.compoundGear.element.style.zIndex = '20';
                }
                if (this.parentGear) {
                    // Outer gear always goes behind, inner gear always goes in front
                    this.parentGear.element.style.zIndex = '10';
                    this.element.style.zIndex = '20';
                }
            }

            bringToFront() {
                // Get the highest z-index currently in use
                let maxZ = 0;
                gears.forEach(gear => {
                    const currentZ = parseInt(gear.element.style.zIndex) || 0;
                    if (currentZ > maxZ) maxZ = currentZ;
                });
                
                // Set this gear's z-index higher than all others
                this.element.style.zIndex = (maxZ + 1).toString();
                
                // For compound gears, maintain proper layering while bringing to front
                if (this.compoundGear) {
                    this.element.style.zIndex = (maxZ + 1).toString();
                    this.compoundGear.element.style.zIndex = (maxZ + 2).toString();
                }
                if (this.parentGear) {
                    this.parentGear.element.style.zIndex = (maxZ + 1).toString();
                    this.element.style.zIndex = (maxZ + 2).toString();
                }
            }

            changeSize(delta) {
                let maxSize = 720;
                let minSize = 60;
                
                // If this is an inner gear (compound gear), limit size to parent gear
                if (this.parentGear) {
                    maxSize = Math.min(maxSize, this.parentGear.size - 20);
                }
                
                // If this has a compound gear, ensure it stays larger than the inner gear
                if (this.compoundGear) {
                    minSize = Math.max(minSize, this.compoundGear.size + 20);
                }
                
                const newSize = Math.max(minSize, Math.min(maxSize, this.size + delta));
                if (newSize !== this.size) {
                    // Store current info box position before changing size
                    // For inner gears, store the parent's info box position
                    const infoGear = this.parentGear || this;
                    const info = infoGear.element.querySelector('.gear-info');
                    let storedInfoLeft = null;
                    let storedInfoTop = null;
                    if (info) {
                        storedInfoLeft = parseFloat(info.style.left);
                        storedInfoTop = parseFloat(info.style.top);
                    }
                    
                    this.size = newSize;
                    this.teeth = this.calculateTeeth();
                    
                    // Update compound gear position to stay centered
                    if (this.compoundGear) {
                        const centerOffsetX = (this.size - this.compoundGear.size) / 2;
                        const centerOffsetY = (this.size - this.compoundGear.size) / 2;
                        this.compoundGear.x = this.x + centerOffsetX;
                        this.compoundGear.y = this.y + centerOffsetY;
                        this.compoundGear.element.style.left = this.compoundGear.x + 'px';
                        this.compoundGear.element.style.top = this.compoundGear.y + 'px';
                    }
                    
                    // Update parent gear position if this is a compound gear
                    if (this.parentGear) {
                        const centerOffsetX = (this.parentGear.size - this.size) / 2;
                        const centerOffsetY = (this.parentGear.size - this.size) / 2;
                        this.parentGear.x = this.x - centerOffsetX;
                        this.parentGear.y = this.y - centerOffsetY;
                        this.parentGear.element.style.left = this.parentGear.x + 'px';
                        this.parentGear.element.style.top = this.parentGear.y + 'px';
                    }
                    
                    // Set proper z-index layering
                    this.updateCompoundLayering();
                    
                    this.findConnections();
                    calculateGearPhysics();
                    
                    const parent = this.element.parentNode;
                    const oldElement = this.element;
                    this.element = this.createElement();
                    parent.replaceChild(this.element, oldElement);
                    
                    // Restore info box position after recreating element
                    // For inner gears, restore to the parent's info box
                    if (storedInfoLeft !== null && storedInfoTop !== null) {
                        const newInfoGear = this.parentGear || this;
                        const newInfo = newInfoGear.element.querySelector('.gear-info');
                        if (newInfo) {
                            newInfo.style.left = storedInfoLeft + 'px';
                            newInfo.style.top = storedInfoTop + 'px';
                        }
                    }
                    
                    this.updateDisplay();
                    drawConnections();
                }
            }

            findConnections() {
                this.connectedGears = [];
                
                // Find direct meshing connections
                gears.forEach(otherGear => {
                    if (otherGear !== this && this.canMeshWith(otherGear)) {
                        this.connectedGears.push(otherGear);
                    }
                });
                
                // Add chain connections
                this.chainConnections.forEach(chain => {
                    const otherGear = chain.gear1 === this ? chain.gear2 : chain.gear1;
                    if (!this.connectedGears.includes(otherGear)) {
                        this.connectedGears.push(otherGear);
                    }
                });
                
                // Update other gears' connections to this gear
                gears.forEach(gear => {
                    if (gear !== this) {
                        gear.connectedGears = gear.connectedGears.filter(g => g !== this);
                        if (gear.canMeshWith(this)) {
                            gear.connectedGears.push(this);
                        }
                        
                        // Add chain connections for other gears too
                        gear.chainConnections.forEach(chain => {
                            const chainOtherGear = chain.gear1 === gear ? chain.gear2 : chain.gear1;
                            if (chainOtherGear === this && !gear.connectedGears.includes(this)) {
                                gear.connectedGears.push(this);
                            }
                        });
                    }
                });
            }

            canMeshWith(otherGear) {
                // Gears can only mesh with gears on the same layer
                if (this.layer !== otherGear.layer) {
                    return false;
                }
                
                const distance = this.getDistanceTo(otherGear);
                const { meshDistance, tolerance } = this.getMeshParameters(otherGear);
                
                return Math.abs(distance - meshDistance) <= tolerance;
            }

            getDistanceTo(otherGear) {
                return Math.sqrt(
                    Math.pow(this.getCenterX() - otherGear.getCenterX(), 2) +
                    Math.pow(this.getCenterY() - otherGear.getCenterY(), 2)
                );
            }

            getMeshParameters(otherGear) {
                let meshDistance, tolerance;
                
                if (this.isRingGear && !otherGear.isRingGear) {
                    // Ring gear with regular gear - internal meshing
                    meshDistance = this.getInnerRadius() - otherGear.getRadius();
                    tolerance = 15;
                } else if (!this.isRingGear && otherGear.isRingGear) {
                    // Regular gear with ring gear - internal meshing
                    meshDistance = otherGear.getInnerRadius() - this.getRadius();
                    tolerance = 15;
                } else if (!this.isRingGear && !otherGear.isRingGear) {
                    // Both regular gears - external meshing
                    meshDistance = this.getRadius() + otherGear.getRadius();
                    tolerance = 15;
                } else {
                    // Both ring gears - no connection possible
                    return { meshDistance: Infinity, tolerance: 0 };
                }
                
                return { meshDistance, tolerance };
            }

            updateDisplay() {
                // Inner compound gears (those with parentGear) should not have their own info boxes
                if (this.parentGear) {
                    // This is an inner compound gear - update the parent's info instead
                    this.parentGear.updateDisplay();
                    return;
                }
                
                const info = this.element.querySelector('.gear-info');
                if (!info) return; // Safety check - gear may have been removed
                
                // Update data attributes to track ownership
                info.setAttribute('data-gear-id', this.id);
                if (this.compoundGear) {
                    info.setAttribute('data-compound-id', this.compoundGear.id);
                } else {
                    info.removeAttribute('data-compound-id');
                }
                
                const motorText = this.isMotor ? '<div style="color: #ef4444; font-weight: bold;">MOTOR</div>' : '';
                const pinnedText = this.isPinned ? '<div style="color: #8b5cf6; font-weight: bold;">PINNED</div>' : '';
                const ringText = this.isRingGear ? '<div style="color: #10b981; font-weight: bold;">RING GEAR</div>' : '';
                const orbitText = this.orbitalRPM > 0 ? `<div style="color: #10b981; font-weight: bold;">ORBITING: ${Math.round(this.orbitalRPM)} RPM</div>` : '';
                const compoundText = this.compoundGear ? '<div style="color: #f59e0b; font-weight: bold;">COMPOUND</div>' : '';
                const jamText = this.isJammed ? '<div style="display:block;width:100%;text-align:center;margin:0.5rem 0;padding:0.25rem;background:#ef4444;color:#fff;font-weight:bold;border-radius:4px;animation: jamPulseBadge 1s infinite;">‚ö†Ô∏è JAMMED</div>': '';
                
                let compoundControls = '';
                if (this.compoundGear) {
                    compoundControls = `
                        <div style="border-top: 1px solid #ccc; margin-top: 0.5rem; padding-top: 0.5rem;">
                            <div style="font-size: 0.7rem; color: #666; margin-bottom: 0.25rem;">Inner Gear (${this.compoundGear.teeth} teeth)</div>
                            <div style="font-size: 0.7rem; margin-bottom: 0.25rem;">
                                <strong>Speed:</strong> ${Math.round(this.compoundGear.rpm)} RPM<br>
                                <strong>Torque:</strong> ${Math.round(this.compoundGear.torque)} Nm
                            </div>
                            <div class="gear-controls">
                                <button class="size-btn" ${isAnimating ? 'disabled style="background: #999; cursor: not-allowed;"' : ''} onclick="event.stopPropagation(); if (isAnimating) return; gears.find(g => g.id === ${this.compoundGear.id}).changeSize(-10)">-</button>
                                <button class="size-btn" ${isAnimating ? 'disabled style="background: #999; cursor: not-allowed;"' : ''} onclick="event.stopPropagation(); if (isAnimating) return; gears.find(g => g.id === ${this.compoundGear.id}).changeSize(10)">+</button>
                            </div>
                        </div>
                    `;
                }
                
                // Hide controls for compound gear parts (inner gears)
                const showControls = !this.parentGear;
                const controlsHtml = showControls ? `
                    <div class="gear-controls">
                        <button class="size-btn" ${isAnimating ? 'disabled style="background: #999; cursor: not-allowed;"' : ''} onclick="event.stopPropagation(); if (isAnimating) return; gears.find(g => g.id === ${this.id}).changeSize(-10)">-</button>
                        <button class="size-btn" ${isAnimating ? 'disabled style="background: #999; cursor: not-allowed;"' : ''} onclick="event.stopPropagation(); if (isAnimating) return; gears.find(g => g.id === ${this.id}).changeSize(10)">+</button>
                        <button class="size-btn" ${isAnimating ? 'disabled style="background: #999; cursor: not-allowed;"' : `style="background: ${this.isMotor ? '#ef4444' : '#6366f1'};"`} onclick="event.stopPropagation(); if (isAnimating) return; gears.find(g => g.id === ${this.id}).toggleMotor()">M</button>
                        <button class="size-btn" ${isAnimating ? 'disabled style="background: #999; cursor: not-allowed;"' : `style="background: ${this.isPinned ? '#8b5cf6' : '#6366f1'};"`} onclick="event.stopPropagation(); if (isAnimating) return; gears.find(g => g.id === ${this.id}).togglePin()">üìå</button>
                        ${!this.compoundGear && !this.parentGear && !this.isRingGear ? `<button class="size-btn" ${isAnimating ? 'disabled style="background: #999; cursor: not-allowed;"' : 'style="background: #f59e0b;"'} onclick="event.stopPropagation(); if (isAnimating) return; gears.find(g => g.id === ${this.id}).addCompoundGear()">C</button>` : ''}
                        <button class="size-btn" style="background: ${isAnimating ? '#999' : '#ef4444'}; cursor: ${isAnimating ? 'not-allowed' : 'pointer'};" onclick="event.stopPropagation(); if (isAnimating) { showWarningPopup(); } else { gears.find(g => g.id === ${this.id}).remove(); }">√ó</button>
                    </div>
                ` : '';
                
                info.innerHTML = `
                    ${motorText}
                    ${pinnedText}
                    ${ringText}
                    ${orbitText}
                    ${compoundText}
                    ${jamText}
                    <div><strong>Teeth:</strong> ${this.teeth}</div>
                    <div><strong>Speed:</strong> ${Math.round(this.rpm)} RPM</div>
                    <div><strong>Torque:</strong> ${Math.round(this.torque)} Nm</div>
                    ${controlsHtml}
                    ${compoundControls}
                `;
                
                this.updatePointer();
                this.updateArrow();
            }

            updateArrow() {
                const arrowSvg = this.element.querySelector('.rotation-arrow');
                if (!arrowSvg) return; // Safety check - gear may have been removed
                arrowSvg.innerHTML = '';
                this.createRotationArrow(arrowSvg);
            }

            updatePointer() {
                const pointer = this.element.querySelector('.info-pointer');
                const info = this.element.querySelector('.gear-info');
                const gearCircle = this.element.querySelector('.gear-circle');
                
                if (!pointer || !info || !gearCircle) return; // Safety check - gear may have been removed
                
                // Get the current transform of the gear circle to account for orbital motion
                const transform = gearCircle.style.transform;
                let offsetX = 0, offsetY = 0;
                
                if (transform && transform.includes('translate')) {
                    const matches = transform.match(/translate\(([^,]+)px,\s*([^)]+)px\)/);
                    if (matches) {
                        offsetX = parseFloat(matches[1]);
                        offsetY = parseFloat(matches[2]);
                    }
                }
                
                const gearCenterX = this.size / 2 + offsetX;
                const gearCenterY = this.size / 2 + offsetY;
                
                const infoCenterX = parseFloat(info.style.left) + 60;
                const infoCenterY = parseFloat(info.style.top) + 25;
                
                const length = Math.sqrt(Math.pow(infoCenterX - gearCenterX, 2) + Math.pow(infoCenterY - gearCenterY, 2));
                const pointerAngle = Math.atan2(infoCenterY - gearCenterY, infoCenterX - gearCenterX) * 180 / Math.PI;
                
                pointer.style.left = gearCenterX + 'px';
                pointer.style.top = gearCenterY + 'px';
                pointer.style.width = length + 'px';
                pointer.style.transform = `rotate(${pointerAngle}deg)`;
            }

            updateLayerVisibility() {
                if (!this.element) return;
                
                if (currentLayer === 'all') {
                    // Show all layers with proper z-index stacking
                    this.element.style.opacity = '1';
                    this.element.style.pointerEvents = 'auto';
                    
                    // Stack layers with higher layer numbers on top
                    // Base z-index of 100, add 10 per layer to ensure proper stacking
                    this.element.style.zIndex = (100 + this.layer * 10).toString();
                } else {
                    const isOnCurrentLayer = this.layer === currentLayer;
                    const opacity = isOnCurrentLayer ? '1' : '0.3';
                    const pointerEvents = isOnCurrentLayer ? 'auto' : 'none';
                    
                    this.element.style.opacity = opacity;
                    this.element.style.pointerEvents = pointerEvents;
                    
                    // Update z-index based on layer
                    this.element.style.zIndex = isOnCurrentLayer ? '100' : '50';
                }
            }

            toggleMotor() {
                if (this.isRingGear) return; // Ring gears cannot be motors
                
                // Remove motor status from all gears
                gears.forEach(gear => {
                    gear.isMotor = false;
                    gear.element.querySelector('.gear-circle').classList.remove('motor-gear');
                });
                
                // Make this gear the motor
                this.isMotor = true;
                this.element.querySelector('.gear-circle').classList.add('motor-gear');
                
                calculateGearPhysics();
                gears.forEach(gear => gear.updateDisplay());
            }

            togglePin() {
                this.isPinned = !this.isPinned;
                
                const circle = this.element.querySelector('.gear-circle');
                if (this.isPinned) {
                    circle.classList.add('pinned-gear');
                } else {
                    circle.classList.remove('pinned-gear');
                }
                
                calculateGearPhysics();
                this.updateDisplay();
            }

            addCompoundGear() {
                if (this.compoundGear || this.parentGear || this.isRingGear) return;
                
                const innerSize = Math.max(40, this.size - 40);
                const centerOffsetX = (this.size - innerSize) / 2;
                const centerOffsetY = (this.size - innerSize) / 2;
                const centerX = this.x + centerOffsetX;
                const centerY = this.y + centerOffsetY;
                
                // Inner gear goes on the next layer up
                const innerLayer = this.layer + 1;
                
                // Add the new layer if it doesn't exist
                if (!layers.includes(innerLayer)) {
                    layers.push(innerLayer);
                    layers.sort((a, b) => a - b);
                    maxLayer = Math.max(maxLayer, innerLayer);
                    updateLayerSelect();
                }
                
                const compoundGear = new Gear(centerX, centerY, innerSize, false, this, innerLayer);
                this.compoundGear = compoundGear;
                
                // Set proper layering - outer gear always behind, inner gear always in front
                this.updateCompoundLayering();
                
                gears.push(compoundGear);
                document.getElementById('workspaceContent').appendChild(compoundGear.element);
                
                compoundGear.findConnections();
                this.findConnections();
                calculateGearPhysics();
                drawConnections();
                updateChainPositions();
                this.updateDisplay();
            }

            remove() {
                const removedLayers = new Set();
                
                // Remove all chain connections involving this gear
                const chainsToRemove = [...this.chainConnections];
                chainsToRemove.forEach(chain => {
                    removeChain(chain);
                });
                
                // Remove compound gear if it exists
                if (this.compoundGear) {
                    // Remove chains from compound gear too
                    const compoundChainsToRemove = [...this.compoundGear.chainConnections];
                    compoundChainsToRemove.forEach(chain => {
                        removeChain(chain);
                    });
                    
                    removedLayers.add(this.compoundGear.layer);
                    gears = gears.filter(g => g !== this.compoundGear);
                    this.compoundGear.element.remove();
                }
                
                // Remove this gear from parent if it's a compound gear
                if (this.parentGear) {
                    this.parentGear.compoundGear = null;
                    this.parentGear.updateDisplay();
                }
                
                removedLayers.add(this.layer);
                gears = gears.filter(g => g !== this);
                this.element.remove();
                
                // Note: Layers are now manually removed via Remove Layer button
                
                // If we removed the motor, make the first remaining regular gear the motor
                if (this.isMotor && gears.length > 0) {
                    const firstRegularGear = gears.find(g => !g.isRingGear && !g.parentGear);
                    if (firstRegularGear) {
                        firstRegularGear.isMotor = true;
                        firstRegularGear.element.querySelector('.gear-circle').classList.add('motor-gear');
                        firstRegularGear.updateDisplay();
                    }
                }
                
                calculateGearPhysics();
                drawConnections();
                updateChainPositions();
            }
        }

        function updateCamera() {
            const workspaceContent = document.getElementById('workspaceContent');
            workspaceContent.style.transform = `translate(${cameraX}px, ${cameraY}px) scale(${cameraZoom})`;
            
            const zoomLevel = document.getElementById('zoomLevel');
            zoomLevel.textContent = Math.round(cameraZoom * 100) + '%';
        }

        function zoomIn() {
            cameraZoom = Math.min(cameraZoom * 1.2, 3);
            updateCamera();
        }

        function zoomOut() {
            cameraZoom = Math.max(cameraZoom / 1.2, 0.1);
            updateCamera();
        }

        function resetView() {
            cameraX = 0;
            cameraY = 0;
            cameraZoom = 1;
            updateCamera();
        }

        function updateLayerSelect() {
            const layerSelect = document.getElementById('layerSelect');
            layerSelect.innerHTML = '';
            
            // Add "Show All" option
            const showAllOption = document.createElement('option');
            showAllOption.value = 'all';
            showAllOption.textContent = 'Show All';
            if (currentLayer === 'all') {
                showAllOption.selected = true;
            }
            layerSelect.appendChild(showAllOption);
            
            layers.forEach(layer => {
                const option = document.createElement('option');
                option.value = layer;
                option.textContent = `Layer ${layer}`;
                if (layer === currentLayer) {
                    option.selected = true;
                }
                layerSelect.appendChild(option);
            });
        }

        function switchLayer(newLayer) {
            if (newLayer === 'all') {
                currentLayer = 'all';
            } else {
                currentLayer = parseInt(newLayer);
            }
            
            // Update visibility for all gears
            gears.forEach(gear => {
                gear.updateLayerVisibility();
            });
        }

        function addLayer() {
            if (isAnimating) return; // Prevent adding layers during animation
            
            const newLayer = maxLayer + 1;
            layers.push(newLayer);
            layers.sort((a, b) => a - b);
            maxLayer = newLayer;
            
            updateLayerSelect();
            
            // Switch to the new layer
            document.getElementById('layerSelect').value = newLayer;
            switchLayer(newLayer);
        }

        function removeCurrentLayer() {
            if (isAnimating) return; // Prevent removing layers during animation
            
            // Cannot remove "Show All" mode
            if (currentLayer === 'all') {
                showLayerWarningPopup("Cannot remove 'Show All' view. Please select a specific layer first.");
                return;
            }
            
            // Cannot remove layer 0
            if (currentLayer === 0) {
                showLayerWarningPopup("Cannot remove Layer 0. This is the base layer and must remain.");
                return;
            }
            
            // Check if there are any gears on this layer (including inner compound gears)
            const gearsOnLayer = gears.filter(gear => gear.layer === currentLayer);
            
            if (gearsOnLayer.length > 0) {
                showLayerWarningPopup("Remove all gears before deleting layer. This layer contains gears that must be deleted first.");
                return;
            }
            
            // Remove the layer
            layers = layers.filter(l => l !== currentLayer);
            
            // Update maxLayer
            maxLayer = Math.max(...layers);
            
            // Switch to layer 0
            currentLayer = 0;
            
            updateLayerSelect();
            
            // Update visibility for all gears
            gears.forEach(gear => {
                gear.updateLayerVisibility();
            });
        }

        function showLayerWarningPopup(message) {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay';
            
            // Create popup
            const popup = document.createElement('div');
            popup.className = 'warning-popup';
            popup.innerHTML = `
                <h3>‚ö†Ô∏è Cannot Remove Layer</h3>
                <p>${message}</p>
                <button onclick="closeLayerWarningPopup()">Got It!</button>
            `;
            
            document.body.appendChild(overlay);
            document.body.appendChild(popup);
            
            // Close on overlay click
            overlay.addEventListener('click', closeLayerWarningPopup);
        }

        function closeLayerWarningPopup() {
            const overlay = document.querySelector('.popup-overlay');
            const popup = document.querySelector('.warning-popup');
            
            if (overlay) overlay.remove();
            if (popup) popup.remove();
        }

        function addGear() {
            if (isAnimating) return; // Prevent adding gears during animation
            
            const workspaceContent = document.getElementById('workspaceContent');
            const rect = document.getElementById('workspace').getBoundingClientRect();
            const x = Math.random() * (rect.width - 150) + 75;
            const y = Math.random() * (rect.height - 150) + 75;
            
            const gear = new Gear(x, y, 80, false, null, currentLayer);
            gears.push(gear);
            workspaceContent.appendChild(gear.element);
            
            gear.findConnections();
            calculateGearPhysics();
            drawConnections();
        }

        function addRingGear() {
            if (isAnimating) return; // Prevent adding ring gears during animation
            
            const workspaceContent = document.getElementById('workspaceContent');
            const rect = document.getElementById('workspace').getBoundingClientRect();
            const ringSize = 200;
            const x = Math.random() * (rect.width - ringSize) + 50;
            const y = Math.random() * (rect.height - ringSize) + 50;
            
            const gear = new Gear(x, y, ringSize, true, null, currentLayer);
            gears.push(gear);
            workspaceContent.appendChild(gear.element);
            
            gear.findConnections();
            calculateGearPhysics();
            drawConnections();
        }

        function clearWorkspace() {
            if (isAnimating) return; // Prevent clearing during animation
            
            // Clear all chains
            chains.forEach(chain => chain.remove());
            chains = [];
            chainCounter = 0;
            
            // Exit chain mode if active
            if (isChainMode) {
                toggleChainMode();
            }
            
            gears.forEach(gear => gear.element.remove());
            gears = [];
            gearCounter = 0;
            clearConnections();
        }

        let motorRPM = 120;

        function updateMotorRPM(value) {
            motorRPM = parseInt(value);
            document.getElementById('rpmValue').textContent = motorRPM;
            calculateGearPhysics();
            gears.forEach(gear => gear.updateDisplay());
        }

        function calculateGearPhysics() {
            // Reset all gear states
            gears.forEach(gear => {
                gear.rpm = 0;
                gear.torque = 100;
                gear.rotationDirection = 'normal';
                gear.orbitalRPM = 0;
                gear.orbitCenter = null;
                gear.orbitalRadius = 0;
                gear.orbitalStartAngle = 0;
                gear.isJammed = false; // Reset jam state
            });

            const motorGear = gears.find(gear => gear.isMotor);
            if (!motorGear) return;

            // Check for gear collisions/jams before calculating motion
            const jammedGears = checkForGearJams();
            if (jammedGears.length > 0) {
                // System is jammed - all connected gears stop
                handleGearJam(jammedGears);
                gears.forEach(gear => gear.updateDisplay());
                return;
            }

            // Check for epicyclic (planetary) configuration
            const pinnedGears = gears.filter(gear => gear.isPinned);
            
            if (pinnedGears.length > 0) {
                // Epicyclic system - find the configuration
                handleEpicyclicSystem(motorGear, pinnedGears);
            } else {
                // Normal gear train - motor rotates and drives the system
                motorGear.rpm = motorRPM;
                motorGear.rotationDirection = 'normal';
                propagateMotion(motorGear, new Set([motorGear]));
            }

            gears.forEach(gear => gear.updateDisplay());
        }

        function checkForGearJams() {
            const jammedGears = [];
            
            // Check all gear pairs that are meshing (not chain connected)
            for (let i = 0; i < gears.length; i++) {
                for (let j = i + 1; j < gears.length; j++) {
                    const gear1 = gears[i];
                    const gear2 = gears[j];
                    
                    // Only check gears on the same layer that can mesh
                    if (gear1.layer === gear2.layer && gear1.canMeshWith(gear2)) {
                        // Check if this is a chain connection (chains don't jam)
                        const isChainConnection = gear1.chainConnections.some(chain => 
                            (chain.gear1 === gear1 && chain.gear2 === gear2) ||
                            (chain.gear1 === gear2 && chain.gear2 === gear1)
                        );
                        
                        if (!isChainConnection) {
                            // Calculate what the rotation directions would be
                            const gear1Direction = calculateExpectedDirection(gear1);
                            const gear2Direction = calculateExpectedDirection(gear2);
                            
                            if (gear1Direction && gear2Direction) {
                                // For meshing gears, check if they would rotate in conflicting directions
                                const shouldBeOpposite = shouldGearsRotateOpposite(gear1, gear2);
                                const actuallyOpposite = gear1Direction !== gear2Direction;
                                
                                if (shouldBeOpposite !== actuallyOpposite) {
                                    // Gears are trying to rotate in the same direction when they should be opposite
                                    // or vice versa - this creates a jam
                                    if (!jammedGears.includes(gear1)) jammedGears.push(gear1);
                                    if (!jammedGears.includes(gear2)) jammedGears.push(gear2);
                                }
                            }
                        }
                    }
                }
            }
            
            return jammedGears;
        }

        function calculateExpectedDirection(gear) {
            // Simulate motion propagation to determine expected direction
            const motorGear = gears.find(g => g.isMotor);
            if (!motorGear || gear === motorGear) {
                return gear.isMotor ? 'normal' : null;
            }
            
            // Use breadth-first search to find path from motor to this gear
            const queue = [{ gear: motorGear, direction: 'normal', visited: new Set([motorGear]) }];
            
            while (queue.length > 0) {
                const { gear: currentGear, direction: currentDirection, visited } = queue.shift();
                
                if (currentGear === gear) {
                    return currentDirection;
                }
                
                // Check all connected gears
                currentGear.connectedGears.forEach(connectedGear => {
                    if (!visited.has(connectedGear)) {
                        const newVisited = new Set(visited);
                        newVisited.add(connectedGear);
                        
                        // Determine direction based on connection type
                        let newDirection;
                        const isChainConnection = currentGear.chainConnections.some(chain => 
                            (chain.gear1 === currentGear && chain.gear2 === connectedGear) ||
                            (chain.gear1 === connectedGear && chain.gear2 === currentGear)
                        );
                        
                        if (isChainConnection) {
                            // Chain connection - same direction
                            newDirection = currentDirection;
                        } else if (shouldGearsRotateOpposite(currentGear, connectedGear)) {
                            // External meshing - opposite direction
                            newDirection = currentDirection === 'normal' ? 'reverse' : 'normal';
                        } else {
                            // Internal meshing - same direction
                            newDirection = currentDirection;
                        }
                        
                        queue.push({ gear: connectedGear, direction: newDirection, visited: newVisited });
                    }
                });
            }
            
            return null; // No path found
        }

        function shouldGearsRotateOpposite(gear1, gear2) {
            // External meshing (both regular gears) - should rotate opposite
            if (!gear1.isRingGear && !gear2.isRingGear) {
                return true;
            }
            
            // Internal meshing (one ring gear, one regular) - should rotate same direction
            if ((gear1.isRingGear && !gear2.isRingGear) || (!gear1.isRingGear && gear2.isRingGear)) {
                return false;
            }
            
            // Both ring gears - shouldn't mesh anyway
            return true;
        }

        function handleGearJam(jammedGears) {
            // Mark all jammed gears
            jammedGears.forEach(gear => {
                gear.isJammed = true;
                gear.rpm = 0;
            });
            
            // Find all gears connected to jammed gears and stop them too
            const allJammedGears = new Set(jammedGears);
            const toCheck = [...jammedGears];
            
            while (toCheck.length > 0) {
                const currentGear = toCheck.shift();
                
                currentGear.connectedGears.forEach(connectedGear => {
                    if (!allJammedGears.has(connectedGear)) {
                        allJammedGears.add(connectedGear);
                        connectedGear.isJammed = true;
                        connectedGear.rpm = 0;
                        toCheck.push(connectedGear);
                    }
                });
            }
            
            // Show jam warning on ALL jammed gears
            showGearJamWarning(Array.from(allJammedGears));
        }

        function showGearJamWarning(jammedGears) {
            // Add animation styles if not already added
            if (!document.getElementById('jamStyles')) {
                const style = document.createElement('style');
                style.id = 'jamStyles';
                style.textContent = `
                    @keyframes jamPulse {
                        0%, 100% { transform: translate(-50%, -50%) scale(1); }
                        50% { transform: translate(-50%, -50%) scale(1.2); }
                    }
                    .jammed-gear {
                        border-color: #ef4444 !important;
                        box-shadow: 0 0 20px rgba(239, 68, 68, 0.8) !important;
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Create jam indicators on ALL jammed gears
            const jamIndicators = [];
            
            jammedGears.forEach(gear => {
                if (gear.element) {
                    // Create jam indicator positioned at the exact center of the gear
                    const jamIndicator = document.createElement('div');
                    jamIndicator.className = 'jam-indicator';
                    jamIndicator.innerHTML = '‚ö†Ô∏èüí•';
                    jamIndicator.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        font-size: 24px;
                        z-index: 1000;
                        animation: jamPulse 1s infinite;
                        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
                        pointer-events: none;
                    `;
                    
                    gear.element.appendChild(jamIndicator);
                    jamIndicators.push(jamIndicator);
                    
                    // Add jammed styling to gear
                    gear.element.querySelector('.gear-circle').classList.add('jammed-gear');
                }
            });
            
            // Remove jam indicators and styling after 3 seconds
            setTimeout(() => {
                jamIndicators.forEach(indicator => {
                    if (indicator.parentNode) {
                        indicator.remove();
                    }
                });
                
                jammedGears.forEach(gear => {
                    if (gear.element) {
                        const circle = gear.element.querySelector('.gear-circle');
                        if (circle) {
                            circle.classList.remove('jammed-gear');
                        }
                    }
                });
            }, 3000);
            
            // Show toast message
            showErrorMessage("‚ö†Ô∏è Gear Jam! Gears are trying to rotate in conflicting directions. Adjust your gear arrangement to fix the jam.");
        }

        function handleEpicyclicSystem(motorGear, pinnedGears) {
            if (motorGear.isPinned) {
                // Motor is pinned (sun gear) - planet gears orbit around it
                motorGear.rpm = 0;
                
                motorGear.connectedGears.forEach(planetGear => {
                    if (!planetGear.isPinned) {
                        setupPlanetaryMotion(motorGear, planetGear);
                        // Propagate motion to other connected gears
                        propagateMotion(planetGear, new Set([motorGear, planetGear]));
                    }
                });
            } else {
                // Motor is not pinned - it drives the system
                motorGear.rpm = motorRPM;
                motorGear.rotationDirection = 'normal';
                
                // Check if motor is connected to any pinned gears
                const connectedPinnedGear = motorGear.connectedGears.find(gear => gear.isPinned);
                
                if (connectedPinnedGear) {
                    // Motor is a planet gear orbiting around a pinned sun gear
                    setupPlanetaryMotion(connectedPinnedGear, motorGear);
                }
                
                // Propagate to all connected gears
                propagateMotion(motorGear, new Set([motorGear]));
            }
        }

        function setupPlanetaryMotion(sunGear, planetGear) {
            // Calculate orbital parameters based on actual gear positions
            const sunCenterX = sunGear.getCenterX();
            const sunCenterY = sunGear.getCenterY();
            const planetCenterX = planetGear.getCenterX();
            const planetCenterY = planetGear.getCenterY();
            
            // Use the actual distance between gears as orbital radius
            const actualDistance = Math.sqrt(
                Math.pow(planetCenterX - sunCenterX, 2) + 
                Math.pow(planetCenterY - sunCenterY, 2)
            );
            
            // Calculate current angle of planet relative to sun
            const currentAngle = Math.atan2(planetCenterY - sunCenterY, planetCenterX - sunCenterX);
            
            // Set up orbital motion
            planetGear.orbitCenter = { x: sunCenterX, y: sunCenterY };
            planetGear.orbitalRadius = actualDistance;
            planetGear.orbitalStartAngle = currentAngle;
            
            // Calculate orbital speed based on gear ratio
            const baseOrbitalRPM = motorRPM / 8; // Slower orbital motion
            planetGear.orbitalRPM = baseOrbitalRPM;
            planetGear.orbitalDirection = 'normal';
            
            // Calculate planet gear's own rotation
            const gearRatio = sunGear.teeth / planetGear.teeth;
            planetGear.rpm = baseOrbitalRPM * (actualDistance / (planetGear.getRadius()));
            planetGear.rotationDirection = 'reverse'; // Opposite to orbital direction
        }

        function propagateMotion(sourceGear, visited) {
            sourceGear.connectedGears.forEach(connectedGear => {
                if (!visited.has(connectedGear)) {
                    visited.add(connectedGear);
                    
                    if (connectedGear.isPinned) {
                        // Connected gear is pinned - it doesn't move
                        connectedGear.rpm = 0;
                        connectedGear.rotationDirection = 'normal';
                        return;
                    }
                    
                    // Calculate gear ratio and motion
                    const gearRatio = sourceGear.teeth / connectedGear.teeth;
                    connectedGear.rpm = Math.abs(sourceGear.rpm) * gearRatio;
                    connectedGear.torque = sourceGear.torque / gearRatio;
                    
                    // Determine rotation direction based on connection type
                    const isChainConnection = sourceGear.chainConnections.some(chain => 
                        (chain.gear1 === sourceGear && chain.gear2 === connectedGear) ||
                        (chain.gear1 === connectedGear && chain.gear2 === sourceGear)
                    );
                    
                    if (isChainConnection) {
                        // Chain connection - same direction (chains don't reverse rotation)
                        connectedGear.rotationDirection = sourceGear.rotationDirection;
                    } else if ((sourceGear.isRingGear && !connectedGear.isRingGear) || (!sourceGear.isRingGear && connectedGear.isRingGear)) {
                        // Internal meshing - same direction
                        connectedGear.rotationDirection = sourceGear.rotationDirection;
                    } else {
                        // External meshing - opposite direction
                        connectedGear.rotationDirection = sourceGear.rotationDirection === 'normal' ? 'reverse' : 'normal';
                    }
                    
                    // If source gear is orbiting, connected gear orbits too
                    if (sourceGear.orbitCenter) {
                        connectedGear.orbitCenter = sourceGear.orbitCenter;
                        connectedGear.orbitalRPM = sourceGear.orbitalRPM;
                        connectedGear.orbitalDirection = sourceGear.orbitalDirection;
                    }
                    
                    // Handle compound gear motion - both gears rotate together
                    if (connectedGear.compoundGear) {
                        connectedGear.compoundGear.rpm = connectedGear.rpm;
                        connectedGear.compoundGear.rotationDirection = connectedGear.rotationDirection;
                        connectedGear.compoundGear.torque = connectedGear.torque;
                        if (connectedGear.orbitCenter) {
                            connectedGear.compoundGear.orbitCenter = connectedGear.orbitCenter;
                            connectedGear.compoundGear.orbitalRPM = connectedGear.orbitalRPM;
                            connectedGear.compoundGear.orbitalDirection = connectedGear.orbitalDirection;
                        }
                    }
                    
                    if (connectedGear.parentGear) {
                        connectedGear.parentGear.rpm = connectedGear.rpm;
                        connectedGear.parentGear.rotationDirection = connectedGear.rotationDirection;
                        connectedGear.parentGear.torque = connectedGear.torque;
                        if (connectedGear.orbitCenter) {
                            connectedGear.parentGear.orbitCenter = connectedGear.orbitCenter;
                            connectedGear.parentGear.orbitalRPM = connectedGear.orbitalRPM;
                            connectedGear.parentGear.orbitalDirection = connectedGear.orbitalDirection;
                        }
                    }
                    
                    propagateMotion(connectedGear, visited);
                    
                    // Also propagate motion from compound parts
                    if (connectedGear.compoundGear) {
                        propagateMotion(connectedGear.compoundGear, visited);
                    }
                    if (connectedGear.parentGear) {
                        propagateMotion(connectedGear.parentGear, visited);
                    }
                }
            });
        }

        function drawConnections() {
            clearConnections();
            const workspace = document.getElementById('workspaceContent');

            gears.forEach(gear => {
                gear.connectedGears.forEach(connectedGear => {
                    if (gear.id < connectedGear.id) {
                        const line = document.createElement('div');
                        line.className = 'connection-line';
                        
                        const x1 = gear.getCenterX();
                        const y1 = gear.getCenterY();
                        const x2 = connectedGear.getCenterX();
                        const y2 = connectedGear.getCenterY();
                        
                        const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                        const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
                        
                        line.style.left = x1 + 'px';
                        line.style.top = y1 + 'px';
                        line.style.width = length + 'px';
                        line.style.transform = `rotate(${angle}deg)`;
                        
                        workspace.appendChild(line);
                    }
                });
            });
        }

        function clearConnections() {
            const lines = document.querySelectorAll('.connection-line');
            lines.forEach(line => line.remove());
        }

        function toggleChainMode() {
            if (isAnimating) {
                showWarningPopup("Please stop the animation before adding chains.");
                return;
            }
            
            isChainMode = !isChainMode;
            const chainBtn = document.getElementById('addChainBtn');
            
            if (isChainMode) {
                chainBtn.style.background = '#f59e0b';
                chainBtn.style.boxShadow = '0 0 10px rgba(245, 158, 11, 0.5)';
                chainBtn.textContent = 'üîó Exit Chain Mode';
                showSuccessMessage("Chain mode activated! Click two gears to connect them with a chain.");
            } else {
                chainBtn.style.background = '#4f46e5';
                chainBtn.style.boxShadow = 'none';
                chainBtn.textContent = 'üîó Add Chain';
                
                // Clean up any pending chain selection
                if (chainStartGear) {
                    chainStartGear.element.querySelector('.gear-circle').classList.remove('chain-mode');
                    chainStartGear = null;
                }
                clearChainPreview();
                showSuccessMessage("Chain mode deactivated.");
            }
        }

        function createChain(gear1, gear2) {
            // Check if chain already exists between these gears
            const existingChain = chains.find(chain => 
                (chain.gear1 === gear1 && chain.gear2 === gear2) ||
                (chain.gear1 === gear2 && chain.gear2 === gear1)
            );
            
            if (existingChain) {
                showErrorMessage("Chain already exists between these gears!");
                return;
            }
            
            // Check if gears are on the same layer
            if (gear1.layer !== gear2.layer) {
                showErrorMessage("Chains can only connect gears on the same layer!");
                return;
            }
            
            // Create the chain
            const chain = new Chain(gear1, gear2);
            chains.push(chain);
            
            // Add chain references to gears
            gear1.chainConnections.push(chain);
            gear2.chainConnections.push(chain);
            
            // Add chain element to workspace
            document.getElementById('workspaceContent').appendChild(chain.element);
            
            // Update connections and physics
            gear1.findConnections();
            gear2.findConnections();
            calculateGearPhysics();
            
            showSuccessMessage("Chain created successfully! üîó");
        }

        function removeChain(chain) {
            // Remove from chains array
            chains = chains.filter(c => c !== chain);
            
            // Remove chain element
            chain.remove();
        }

        function updateChainPositions() {
            chains.forEach(chain => {
                if (chain.isValid()) {
                    chain.updatePosition();
                } else {
                    // Remove invalid chains
                    removeChain(chain);
                }
            });
        }

        function clearChainPreview() {
            if (chainPreview) {
                chainPreview.remove();
                chainPreview = null;
            }
        }

        let animationFrame;

        function toggleAnimation() {
            isAnimating = !isAnimating;
            
            if (isAnimating) {
                startAnimation();
            } else {
                stopAnimation();
            }
            
            // Update button states
            updateButtonStates();
            
            // Update all gear displays to reflect animation state
            gears.forEach(gear => gear.updateDisplay());
        }

        function updateButtonStates() {
            const addGearBtn = document.getElementById('addGearBtn');
            const addRingGearBtn = document.getElementById('addRingGearBtn');
            const addChainBtn = document.getElementById('addChainBtn');
            const addLayerBtn = document.getElementById('addLayerBtn');
            const removeLayerBtn = document.getElementById('removeLayerBtn');
            const clearBtn = document.getElementById('clearBtn');
            
            if (isAnimating) {
                // Disable buttons during animation
                addGearBtn.disabled = true;
                addGearBtn.style.background = '#999';
                addGearBtn.style.cursor = 'not-allowed';
                
                addRingGearBtn.disabled = true;
                addRingGearBtn.style.background = '#999';
                addRingGearBtn.style.cursor = 'not-allowed';
                
                addChainBtn.disabled = true;
                addChainBtn.style.background = '#999';
                addChainBtn.style.cursor = 'not-allowed';
                
                addLayerBtn.disabled = true;
                addLayerBtn.style.background = '#999';
                addLayerBtn.style.cursor = 'not-allowed';
                
                removeLayerBtn.disabled = true;
                removeLayerBtn.style.background = '#999';
                removeLayerBtn.style.cursor = 'not-allowed';
                
                clearBtn.disabled = true;
                clearBtn.style.background = '#999';
                clearBtn.style.cursor = 'not-allowed';
            } else {
                // Re-enable buttons when animation stops
                addGearBtn.disabled = false;
                addGearBtn.style.background = '#4f46e5';
                addGearBtn.style.cursor = 'pointer';
                
                addRingGearBtn.disabled = false;
                addRingGearBtn.style.background = '#4f46e5';
                addRingGearBtn.style.cursor = 'pointer';
                
                addChainBtn.disabled = false;
                // Keep chain mode styling if active
                if (!isChainMode) {
                    addChainBtn.style.background = '#4f46e5';
                    addChainBtn.style.boxShadow = 'none';
                }
                addChainBtn.style.cursor = 'pointer';
                
                addLayerBtn.disabled = false;
                addLayerBtn.style.background = '#4f46e5';
                addLayerBtn.style.cursor = 'pointer';
                
                removeLayerBtn.disabled = false;
                removeLayerBtn.style.background = '#ef4444';
                removeLayerBtn.style.cursor = 'pointer';
                
                clearBtn.disabled = false;
                clearBtn.style.background = '#ef4444';
                clearBtn.style.cursor = 'pointer';
            }
        }

        function startAnimation() {
            // Store original info positions and move them to workspace
            const workspace = document.getElementById('workspaceContent');
            clearConnections();
            
            gears.forEach(gear => {
                const info = gear.element?.querySelector('.gear-info');
                const pointer = gear.element?.querySelector('.info-pointer');
                
                if (!info || !pointer) return; // Skip if elements don't exist
                
                // Hide pointer
                pointer.style.display = 'none';
                
                // Store original position relative to gear
                gear.originalInfoLeft = parseFloat(info.style.left);
                gear.originalInfoTop = parseFloat(info.style.top);
                
                // Calculate absolute position in workspace
                const absoluteX = gear.x + gear.originalInfoLeft;
                const absoluteY = gear.y + gear.originalInfoTop;
                
                // Move info box to workspace with absolute positioning (relative to workspace, not viewport)
                info.style.position = 'absolute';
                info.style.left = absoluteX + 'px';
                info.style.top = absoluteY + 'px';
                info.style.zIndex = '1000';
                
                // Remove from gear and add to workspace
                workspace.appendChild(info);
            });
            
            const startTime = Date.now();
            
            function animate() {
                if (!isAnimating) return;
                
                const currentTime = Date.now();
                const elapsed = (currentTime - startTime) / 1000; // seconds
                
                gears.forEach((gear) => {
                    if (!gear.element) return; // Skip if gear element doesn't exist
                    
                    const circle = gear.element.querySelector('.gear-circle');
                    const teeth = gear.element.querySelector('.gear-teeth');
                    const arrow = gear.element.querySelector('.rotation-arrow');
                    
                    if (!circle || !teeth || !arrow) return; // Skip if elements don't exist
                    
                    if (gear.rpm > 0) {
                        // Handle gear rotation
                        const rotationClass = gear.rotationDirection === 'reverse' ? 'rotating-reverse' : 'rotating';
                        circle.classList.add(rotationClass);
                        teeth.classList.add(rotationClass);
                        arrow.classList.add(rotationClass);
                        
                        const duration = 60 / Math.abs(gear.rpm); // seconds per revolution
                        circle.style.animationDuration = duration + 's';
                        teeth.style.animationDuration = duration + 's';
                        arrow.style.animationDuration = duration + 's';
                        
                        // Handle orbital motion - move the entire gear element
                        if (gear.orbitCenter && gear.orbitalRPM > 0) {
                            const orbitalPeriod = 60 / Math.abs(gear.orbitalRPM); // seconds per revolution
                            const angle = (elapsed / orbitalPeriod) * 2 * Math.PI;
                            const adjustedAngle = gear.orbitalDirection === 'reverse' ? -angle : angle;
                            
                            // Calculate new orbital position
                            const newX = gear.orbitCenter.x + gear.orbitalRadius * Math.cos(gear.orbitalStartAngle + adjustedAngle);
                            const newY = gear.orbitCenter.y + gear.orbitalRadius * Math.sin(gear.orbitalStartAngle + adjustedAngle);
                            
                            // Move the entire gear element to the new position
                            const gearElement = gear.element;
                            if (gearElement && gearElement.style) {
                                gearElement.style.left = (newX - gear.size / 2) + 'px';
                                gearElement.style.top = (newY - gear.size / 2) + 'px';
                            }
                        }
                    } else {
                        circle.classList.remove('rotating', 'rotating-reverse');
                        teeth.classList.remove('rotating', 'rotating-reverse');
                        arrow.classList.remove('rotating', 'rotating-reverse');
                    }
                });
                
                // Update chain positions during orbital motion
                updateChainPositions();
                
                // Animate chains manually
                chains.forEach(chain => {
                    if (!chain.element) return;
                    
                    // Calculate chain speed based on connected gears
                    const gear1Speed = Math.abs(chain.gear1.rpm);
                    const gear2Speed = Math.abs(chain.gear2.rpm);
                    const averageSpeed = (gear1Speed + gear2Speed) / 2;
                    
                    if (averageSpeed > 0) {
                        // Calculate animation parameters - faster gears = faster chain movement
                        const baseSpeed = 30; // pixels per second at 60 RPM
                        const pixelsPerSecond = baseSpeed * (averageSpeed / 60);
                        
                        // Get gear rotation directions
                        const gear1Direction = chain.gear1.rotationDirection;
                        const gear2Direction = chain.gear2.rotationDirection;
                        
                        // Calculate base offset
                        const baseOffset = (elapsed * pixelsPerSecond) % 20;
                        
                        // Apply animation to chain segments with proper directional flow
                        const chainSegments = chain.element.querySelectorAll('.chain-segment');
                        chainSegments.forEach(segment => {
                            const segmentType = segment.getAttribute('data-segment-type');
                            const segmentAngle = parseFloat(segment.getAttribute('data-angle')) || 0;
                            
                            let offset = baseOffset;
                            
                            // Determine flow direction based on segment type and gear rotations
                            if (segmentType === 'top-straight') {
                                // Top segment flows in direction of gear1's rotation
                                if (gear1Direction === 'normal') {
                                    offset = 20 - offset;
                                }
                            } else if (segmentType === 'bottom-straight') {
                                // Bottom segment flows opposite to top segment
                                if (gear1Direction === 'reverse') {
                                    offset = 20 - offset;
                                }
                            } else if (segmentType === 'arc-gear1') {
                                // Arc around gear1 follows gear1's rotation
                                if (gear1Direction === 'normal') {
                                    offset = 20 - offset;
                                }
                            } else if (segmentType === 'arc-gear2') {
                                // Arc around gear2 follows gear2's rotation
                                if (gear2Direction === 'normal') {
                                    offset = 20 - offset;
                                }
                            }
                            
                            // Update CSS custom properties for pseudo-elements
                            segment.style.setProperty('--before-position', `${offset}px 0px`);
                            segment.style.setProperty('--after-position', `${offset}px 0px`);
                        });
                    }
                });
                
                animationFrame = requestAnimationFrame(animate);
            }
            
            animate();
        }



        function stopAnimation() {
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
            
            // Stop chain animations
            chains.forEach(chain => {
                chain.stopAnimation();
            });
            
            gears.forEach((gear) => {
                if (!gear.element) return; // Skip if gear element doesn't exist
                
                const circle = gear.element.querySelector('.gear-circle');
                const teeth = gear.element.querySelector('.gear-teeth');
                const arrow = gear.element.querySelector('.rotation-arrow');
                
                if (circle) circle.classList.remove('rotating', 'rotating-reverse');
                if (teeth) teeth.classList.remove('rotating', 'rotating-reverse');
                if (arrow) arrow.classList.remove('rotating', 'rotating-reverse');
                
                // Reset gear positions to original
                if (gear.element && gear.element.style) {
                    gear.element.style.left = gear.x + 'px';
                    gear.element.style.top = gear.y + 'px';
                }
            });
            
            // Reconnect all info boxes back to their gears
            const workspace = document.getElementById('workspace');
            
            // Process ALL gears that should have info boxes
            // This includes: outer compound gears, regular gears, and inner compound gears
            gears.forEach(gear => {
                // Skip inner compound gears - their info is handled by the parent
                if (!gear.parentGear) {
                    reconnectInfoBox(gear, workspace);
                }
            });
            
            // Clean up any orphaned info boxes
            cleanupOrphanedInfoBoxes(workspace);
            
            // Restore connections
            drawConnections();
        }

        function reconnectInfoBox(gear, workspace) {
            if (!gear.element) return;
            
            console.log(`Reconnecting info for gear ${gear.id}, compound: ${gear.compoundGear ? gear.compoundGear.id : 'none'}`);
            
            // First check if gear already has an info box attached
            const existingInfo = gear.element.querySelector('.gear-info');
            if (existingInfo) {
                console.log(`Gear ${gear.id} already has info box attached, skipping reconnection`);
                // Just make sure pointer is visible and positioned correctly
                const pointer = gear.element.querySelector('.info-pointer');
                if (pointer) {
                    pointer.style.display = 'block';
                    gear.updatePointer();
                }
                return;
            }
            
            // Look for detached info box in workspace using data attributes
            const detachedInfos = workspace.querySelectorAll('.gear-info');
            let matchingInfo = null;
            
            console.log(`Found ${detachedInfos.length} detached info boxes in workspace`);
            
            for (let info of detachedInfos) {
                const infoGearId = parseInt(info.getAttribute('data-gear-id'));
                const infoCompoundId = info.getAttribute('data-compound-id');
                
                console.log(`Checking info: gear-id=${infoGearId}, compound-id=${infoCompoundId}`);
                
                // Match based on the main gear ID
                if (infoGearId === gear.id) {
                    // For compound gears, also check compound ID matches
                    if (gear.compoundGear) {
                        if (infoCompoundId && parseInt(infoCompoundId) === gear.compoundGear.id) {
                            matchingInfo = info;
                            console.log(`Found compound gear match for gear ${gear.id}`);
                            break;
                        }
                    } else {
                        // For regular gears, accept if no compound ID or if compound ID doesn't matter
                        matchingInfo = info;
                        console.log(`Found regular gear match for gear ${gear.id}`);
                        break;
                    }
                }
            }
            
            if (matchingInfo) {
                console.log(`Reconnecting info box for gear ${gear.id}`);
                
                // Reset info box positioning and move back to gear
                matchingInfo.style.position = 'absolute';
                matchingInfo.style.left = (gear.originalInfoLeft || (gear.size + 20)) + 'px';
                matchingInfo.style.top = (gear.originalInfoTop || 0) + 'px';
                matchingInfo.style.zIndex = '100';
                
                // Move back to gear element
                gear.element.appendChild(matchingInfo);
                
                // Ensure pointer is visible and properly positioned
                const pointer = gear.element.querySelector('.info-pointer');
                if (pointer) {
                    pointer.style.display = 'block';
                    gear.updatePointer();
                }
            } else {
                console.log(`No matching info found for gear ${gear.id}, recreating`);
                // If no matching info found, recreate it
                gear.updateDisplay();
            }
        }

        function cleanupOrphanedInfoBoxes(workspace) {
            const orphanedInfos = workspace.querySelectorAll('.gear-info');
            console.log(`Cleanup: Found ${orphanedInfos.length} info boxes still in workspace`);
            
            orphanedInfos.forEach((info, index) => {
                const infoGearId = info.getAttribute('data-gear-id');
                const infoCompoundId = info.getAttribute('data-compound-id');
                console.log(`Cleanup [${index}]: gear-id=${infoGearId}, compound-id=${infoCompoundId}`);
                
                // Check if this info belongs to any existing gear using data attributes
                const belongsToGear = gears.some(gear => {
                    if (parseInt(infoGearId) === gear.id) {
                        // If it's a compound gear, check compound ID too
                        if (gear.compoundGear && infoCompoundId) {
                            return parseInt(infoCompoundId) === gear.compoundGear.id;
                        }
                        // For regular gears, just matching the main ID is enough
                        return true;
                    }
                    return false;
                });
                
                console.log(`Cleanup [${index}]: belongsToGear=${belongsToGear}`);
                
                if (!belongsToGear) {
                    console.log(`Cleanup [${index}]: Removing orphaned info box`);
                    info.remove();
                } else {
                    console.log(`Cleanup [${index}]: Keeping info box (belongs to existing gear)`);
                }
            });
        }

        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('touchmove', handleDrag);
        document.addEventListener('mouseup', stopDrag);
        document.addEventListener('touchend', stopDrag);

        function handleDrag(e) {
            if (draggedGear) {
                e.preventDefault();
                const workspace = document.getElementById('workspace');
                const rect = workspace.getBoundingClientRect();
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                // Convert screen coordinates to workspace coordinates accounting for zoom and pan
                const workspaceX = (clientX - rect.left - cameraX) / cameraZoom;
                const workspaceY = (clientY - rect.top - cameraY) / cameraZoom;
                
                const x = workspaceX - dragOffset.x;
                const y = workspaceY - dragOffset.y;
                
                draggedGear.updatePosition(x, y);
            } else if (draggedInfo) {
                e.preventDefault();
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                const relativeX = clientX - draggedInfo.x - dragOffset.x;
                const relativeY = clientY - draggedInfo.y - dragOffset.y;
                
                const info = draggedInfo.element?.querySelector('.gear-info');
                if (info && info.style) {
                    info.style.left = relativeX + 'px';
                    info.style.top = relativeY + 'px';
                    
                    draggedInfo.updatePointer();
                }
            } else if (isPanning) {
                e.preventDefault();
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                cameraX = panOffset.x + (clientX - panStart.x);
                cameraY = panOffset.y + (clientY - panStart.y);
                updateCamera();
            } else if (isChainMode && chainStartGear) {
                // Show chain preview when in chain mode
                updateChainPreview(e);
            }
        }

        function updateChainPreview(e) {
            if (!chainStartGear) return;
            
            const workspace = document.getElementById('workspace');
            const rect = workspace.getBoundingClientRect();
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            
            // Convert to workspace coordinates
            const workspaceX = (clientX - rect.left - cameraX) / cameraZoom;
            const workspaceY = (clientY - rect.top - cameraY) / cameraZoom;
            
            // Find gear under cursor
            const hoveredGear = gears.find(gear => {
                if (gear === chainStartGear || gear.layer !== currentLayer) return false;
                
                const gearCenterX = gear.getCenterX();
                const gearCenterY = gear.getCenterY();
                const distance = Math.sqrt(
                    Math.pow(workspaceX - gearCenterX, 2) + 
                    Math.pow(workspaceY - gearCenterY, 2)
                );
                return distance <= gear.getRadius();
            });
            
            if (hoveredGear) {
                // Show preview to hovered gear
                showChainPreview(chainStartGear, hoveredGear);
            } else {
                // Show preview to cursor position
                showChainPreviewToCursor(chainStartGear, workspaceX, workspaceY);
            }
        }

        function showChainPreview(gear1, gear2) {
            clearChainPreview();
            
            const preview = document.createElement('div');
            preview.className = 'chain-preview';
            preview.style.position = 'absolute';
            preview.style.pointerEvents = 'none';
            preview.style.zIndex = '10';
            
            // Create a simplified preview showing the main chain path
            const center1 = { x: gear1.getCenterX(), y: gear1.getCenterY() };
            const center2 = { x: gear2.getCenterX(), y: gear2.getCenterY() };
            const radius1 = gear1.getRadius();
            const radius2 = gear2.getRadius();
            
            const dx = center2.x - center1.x;
            const dy = center2.y - center1.y;
            const centerDistance = Math.sqrt(dx * dx + dy * dy);
            const centerAngle = Math.atan2(dy, dx);
            
            // Calculate tangent points (simplified for preview)
            let tangentAngle1, tangentAngle2;
            
            if (Math.abs(radius1 - radius2) < centerDistance) {
                const radiusDiff = radius2 - radius1;
                const tangentOffset = Math.asin(radiusDiff / centerDistance);
                tangentAngle1 = centerAngle + Math.PI/2 + tangentOffset;
                tangentAngle2 = centerAngle + Math.PI/2 + tangentOffset;
            } else {
                tangentAngle1 = centerAngle;
                tangentAngle2 = centerAngle;
            }
            
            // Create preview segments for the main chain path
            const tangent1 = {
                x: center1.x + radius1 * Math.cos(tangentAngle1),
                y: center1.y + radius1 * Math.sin(tangentAngle1)
            };
            
            const tangent2 = {
                x: center2.x + radius2 * Math.cos(tangentAngle2),
                y: center2.y + radius2 * Math.sin(tangentAngle2)
            };
            
            // Create the main straight segment for preview
            const previewSegment = document.createElement('div');
            previewSegment.className = 'chain-preview-segment';
            
            const length = Math.sqrt(Math.pow(tangent2.x - tangent1.x, 2) + Math.pow(tangent2.y - tangent1.y, 2));
            const chainAngle = Math.atan2(tangent2.y - tangent1.y, tangent2.x - tangent1.x) * 180 / Math.PI;
            
            previewSegment.style.position = 'absolute';
            previewSegment.style.left = tangent1.x + 'px';
            previewSegment.style.top = (tangent1.y - 6) + 'px';
            previewSegment.style.width = length + 'px';
            previewSegment.style.height = '12px';
            previewSegment.style.transform = `rotate(${chainAngle}deg)`;
            previewSegment.style.transformOrigin = 'left center';
            
            preview.appendChild(previewSegment);
            
            // Add simplified arc indicators
            const arc1 = document.createElement('div');
            arc1.style.position = 'absolute';
            arc1.style.left = (center1.x - radius1) + 'px';
            arc1.style.top = (center1.y - radius1) + 'px';
            arc1.style.width = (radius1 * 2) + 'px';
            arc1.style.height = (radius1 * 2) + 'px';
            arc1.style.border = '2px dashed #f59e0b';
            arc1.style.borderRadius = '50%';
            arc1.style.opacity = '0.5';
            preview.appendChild(arc1);
            
            const arc2 = document.createElement('div');
            arc2.style.position = 'absolute';
            arc2.style.left = (center2.x - radius2) + 'px';
            arc2.style.top = (center2.y - radius2) + 'px';
            arc2.style.width = (radius2 * 2) + 'px';
            arc2.style.height = (radius2 * 2) + 'px';
            arc2.style.border = '2px dashed #f59e0b';
            arc2.style.borderRadius = '50%';
            arc2.style.opacity = '0.5';
            preview.appendChild(arc2);
            
            chainPreview = preview;
            document.getElementById('workspaceContent').appendChild(preview);
        }

        function showChainPreviewToCursor(gear, cursorX, cursorY) {
            clearChainPreview();
            
            const preview = document.createElement('div');
            preview.className = 'chain-preview';
            
            const previewSegment = document.createElement('div');
            previewSegment.className = 'chain-preview-segment';
            preview.appendChild(previewSegment);
            
            // Simple line from gear edge to cursor
            const gearCenterX = gear.getCenterX();
            const gearCenterY = gear.getCenterY();
            const angle = Math.atan2(cursorY - gearCenterY, cursorX - gearCenterX);
            
            const x1 = gearCenterX + gear.getRadius() * Math.cos(angle);
            const y1 = gearCenterY + gear.getRadius() * Math.sin(angle);
            
            const length = Math.sqrt(Math.pow(cursorX - x1, 2) + Math.pow(cursorY - y1, 2));
            const chainAngle = Math.atan2(cursorY - y1, cursorX - x1) * 180 / Math.PI;
            
            preview.style.left = x1 + 'px';
            preview.style.top = (y1 - 6) + 'px';
            preview.style.width = length + 'px';
            preview.style.transform = `rotate(${chainAngle}deg)`;
            
            chainPreview = preview;
            document.getElementById('workspaceContent').appendChild(preview);
        }

        function stopDrag() {
            draggedGear = null;
            draggedInfo = null;
            isPanning = false;
            document.getElementById('workspace').classList.remove('panning');
        }

        function showWarningPopup() {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay';
            
            // Create popup
            const popup = document.createElement('div');
            popup.className = 'warning-popup';
            popup.innerHTML = `
                <h3>‚ö†Ô∏è Cannot Delete During Animation</h3>
                <p>Please stop the animation first before deleting gears. This prevents the system from crashing while gears are in motion.</p>
                <button onclick="closeWarningPopup()">Got It!</button>
            `;
            
            document.body.appendChild(overlay);
            document.body.appendChild(popup);
            
            // Close on overlay click
            overlay.addEventListener('click', closeWarningPopup);
        }

        function closeWarningPopup() {
            const overlay = document.querySelector('.popup-overlay');
            const popup = document.querySelector('.warning-popup');
            
            if (overlay) overlay.remove();
            if (popup) popup.remove();
        }

        function updateDebugInfo() {
            const debugGears = document.getElementById('debugGears');
            const debugInfos = document.getElementById('debugInfos');
            const debugChains = document.getElementById('debugChains');
            
            // Debug gears array
            let gearsInfo = `Total gears: ${gears.length}<br><br>`;
            gears.forEach((gear, index) => {
                gearsInfo += `[${index}] ID:${gear.id} ${gear.isRingGear ? 'RING' : 'REG'} `;
                gearsInfo += `${gear.parentGear ? 'INNER' : ''}${gear.compoundGear ? 'OUTER' : ''}<br>`;
                gearsInfo += `    Element: ${gear.element ? 'EXISTS' : 'MISSING'}<br>`;
                if (gear.element) {
                    gearsInfo += `    In DOM: ${document.contains(gear.element) ? 'YES' : 'NO'}<br>`;
                    const info = gear.element.querySelector('.gear-info');
                    gearsInfo += `    Has Info: ${info ? 'YES' : 'NO'}<br>`;
                    if (info) {
                        gearsInfo += `    Info Parent: ${info.parentElement === gear.element ? 'GEAR' : 'OTHER'}<br>`;
                    }
                }
                gearsInfo += `    Chain Connections: ${gear.chainConnections.length}<br>`;
                gearsInfo += `<br>`;
            });
            debugGears.innerHTML = gearsInfo;
            
            // Debug info boxes
            const workspace = document.getElementById('workspace');
            const allInfos = document.querySelectorAll('.gear-info');
            const workspaceInfos = workspace.querySelectorAll('.gear-info');
            
            let infosInfo = `Total .gear-info elements: ${allInfos.length}<br>`;
            infosInfo += `In workspace: ${workspaceInfos.length}<br>`;
            infosInfo += `In gear elements: ${allInfos.length - workspaceInfos.length}<br><br>`;
            
            allInfos.forEach((info, index) => {
                infosInfo += `[${index}] Parent: ${info.parentElement.id || info.parentElement.className}<br>`;
                
                // Use data attributes to identify gear ownership
                const dataGearId = info.getAttribute('data-gear-id');
                const dataCompoundId = info.getAttribute('data-compound-id');
                
                infosInfo += `    Data Gear ID: ${dataGearId || 'NONE'}<br>`;
                if (dataCompoundId) {
                    infosInfo += `    Data Compound ID: ${dataCompoundId}<br>`;
                }
                
                // Check if the gear exists
                const gear = gears.find(g => g.id == dataGearId);
                infosInfo += `    Gear exists: ${gear ? 'YES' : 'NO'}<br>`;
                
                if (gear && dataCompoundId) {
                    const compoundGear = gears.find(g => g.id == dataCompoundId);
                    infosInfo += `    Compound gear exists: ${compoundGear ? 'YES' : 'NO'}<br>`;
                }
                
                infosInfo += `<br>`;
            });
            
            debugInfos.innerHTML = infosInfo;
            
            // Debug chains
            let chainsInfo = `Total chains: ${chains.length}<br>`;
            chainsInfo += `Chain counter: ${chainCounter}<br><br>`;
            
            chains.forEach((chain, index) => {
                chainsInfo += `[${index}] Chain ID: ${chain.id}<br>`;
                chainsInfo += `    Gear1: ID ${chain.gear1.id} (${chain.gear1.isRingGear ? 'RING' : 'REG'})<br>`;
                chainsInfo += `    Gear2: ID ${chain.gear2.id} (${chain.gear2.isRingGear ? 'RING' : 'REG'})<br>`;
                chainsInfo += `    Element: ${chain.element ? 'EXISTS' : 'MISSING'}<br>`;
                if (chain.element) {
                    chainsInfo += `    In DOM: ${document.contains(chain.element) ? 'YES' : 'NO'}<br>`;
                    const segments = chain.element.querySelectorAll('.chain-segment');
                    chainsInfo += `    Segments: ${segments.length}<br>`;
                }
                chainsInfo += `    Valid: ${chain.isValid() ? 'YES' : 'NO'}<br>`;
                chainsInfo += `    Layer Match: ${chain.gear1.layer === chain.gear2.layer ? 'YES' : 'NO'}<br>`;
                chainsInfo += `<br>`;
            });
            
            // Check for orphaned chain elements
            const allChainElements = document.querySelectorAll('.chain-connection');
            chainsInfo += `DOM chain elements: ${allChainElements.length}<br>`;
            if (allChainElements.length !== chains.length) {
                chainsInfo += `<span style="color: #ef4444;">MISMATCH! Expected ${chains.length}</span><br>`;
            }
            
            debugChains.innerHTML = chainsInfo;
        }

        // Auto-update debug info periodically
        setInterval(updateDebugInfo, 2000);

        function toggleDebugPanel() {
            const debugPanel = document.getElementById('debugPanel');
            if (debugPanel.style.display === 'none') {
                debugPanel.style.display = 'block';
                updateDebugInfo(); // Refresh when showing
            } else {
                debugPanel.style.display = 'none';
            }
        }

        // Add workspace event listeners
        document.getElementById('workspace').addEventListener('mousedown', (e) => {
            // Only start panning if clicking on empty space (not on gears or controls)
            if (e.target.id === 'workspace' || e.target.id === 'workspaceContent') {
                isPanning = true;
                panStart.x = e.clientX;
                panStart.y = e.clientY;
                panOffset.x = cameraX;
                panOffset.y = cameraY;
                document.getElementById('workspace').classList.add('panning');
                e.preventDefault();
            }
        });

        // Mouse wheel zoom
        document.getElementById('workspace').addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const rect = document.getElementById('workspace').getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Calculate zoom point in workspace coordinates
            const zoomPointX = (mouseX - cameraX) / cameraZoom;
            const zoomPointY = (mouseY - cameraY) / cameraZoom;
            
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(3, cameraZoom * zoomFactor));
            
            // Adjust camera position to zoom towards mouse cursor
            cameraX = mouseX - zoomPointX * newZoom;
            cameraY = mouseY - zoomPointY * newZoom;
            cameraZoom = newZoom;
            
            updateCamera();
        });

        function saveGearSetup() {
            if (isAnimating) {
                showWarningPopup("Please stop the animation before saving your gear setup.");
                return;
            }
            
            const setupData = {
                version: "1.1",
                timestamp: new Date().toISOString(),
                motorRPM: motorRPM,
                currentLayer: currentLayer,
                layers: [...layers],
                maxLayer: maxLayer,
                camera: {
                    x: cameraX,
                    y: cameraY,
                    zoom: cameraZoom
                },
                gears: gears.map(gear => ({
                    id: gear.id,
                    x: gear.x,
                    y: gear.y,
                    size: gear.size,
                    isRingGear: gear.isRingGear,
                    isMotor: gear.isMotor,
                    isPinned: gear.isPinned,
                    layer: gear.layer,
                    parentGearId: gear.parentGear ? gear.parentGear.id : null,
                    compoundGearId: gear.compoundGear ? gear.compoundGear.id : null,
                    // Store info box position
                    infoX: gear.element?.querySelector('.gear-info') ? parseFloat(gear.element.querySelector('.gear-info').style.left) : (gear.size + 20),
                    infoY: gear.element?.querySelector('.gear-info') ? parseFloat(gear.element.querySelector('.gear-info').style.top) : 0
                })),
                chains: chains.map(chain => ({
                    id: chain.id,
                    gear1Id: chain.gear1.id,
                    gear2Id: chain.gear2.id
                }))
            };
            
            const jsonString = JSON.stringify(setupData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `gear-setup-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showSuccessMessage("Gear setup saved successfully! üíæ");
        }
        
        function loadGearSetup() {
            if (isAnimating) {
                showWarningPopup("Please stop the animation before loading a gear setup.");
                return;
            }
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const setupData = JSON.parse(e.target.result);
                        
                        // Validate the data structure
                        if (!setupData.version || !setupData.gears || !Array.isArray(setupData.gears)) {
                            throw new Error("Invalid gear setup file format");
                        }
                        
                        // Clear current setup
                        clearWorkspace();
                        
                        // Restore global settings
                        if (setupData.motorRPM) {
                            motorRPM = setupData.motorRPM;
                            document.getElementById('rpmSlider').value = motorRPM;
                            document.getElementById('rpmValue').textContent = motorRPM;
                        }
                        
                        if (setupData.layers) {
                            layers = [...setupData.layers];
                            maxLayer = setupData.maxLayer || Math.max(...layers);
                            updateLayerSelect();
                        }
                        
                        if (setupData.camera) {
                            cameraX = setupData.camera.x || 0;
                            cameraY = setupData.camera.y || 0;
                            cameraZoom = setupData.camera.zoom || 1;
                            updateCamera();
                        }
                        
                        // Restore gears in two passes to handle compound gear relationships
                        const gearMap = new Map();
                        const workspaceContent = document.getElementById('workspaceContent');
                        
                        // First pass: Create all regular gears and outer compound gears
                        setupData.gears.forEach(gearData => {
                            if (!gearData.parentGearId) { // Skip inner compound gears for now
                                const gear = new Gear(
                                    gearData.x,
                                    gearData.y,
                                    gearData.size,
                                    gearData.isRingGear,
                                    null, // No parent yet
                                    gearData.layer
                                );
                                
                                // Restore properties
                                gear.id = gearData.id;
                                gear.isMotor = gearData.isMotor || false;
                                gear.isPinned = gearData.isPinned || false;
                                
                                // Update gear counter to avoid ID conflicts
                                gearCounter = Math.max(gearCounter, gear.id);
                                
                                gearMap.set(gear.id, gear);
                                gears.push(gear);
                                workspaceContent.appendChild(gear.element);
                                
                                // Restore info box position
                                const info = gear.element.querySelector('.gear-info');
                                if (info && gearData.infoX !== undefined && gearData.infoY !== undefined) {
                                    info.style.left = gearData.infoX + 'px';
                                    info.style.top = gearData.infoY + 'px';
                                }
                            }
                        });
                        
                        // Second pass: Create inner compound gears and establish relationships
                        setupData.gears.forEach(gearData => {
                            if (gearData.parentGearId) {
                                const parentGear = gearMap.get(gearData.parentGearId);
                                if (parentGear) {
                                    const gear = new Gear(
                                        gearData.x,
                                        gearData.y,
                                        gearData.size,
                                        gearData.isRingGear,
                                        parentGear,
                                        gearData.layer
                                    );
                                    
                                    gear.id = gearData.id;
                                    gear.isMotor = gearData.isMotor || false;
                                    gear.isPinned = gearData.isPinned || false;
                                    
                                    gearCounter = Math.max(gearCounter, gear.id);
                                    
                                    parentGear.compoundGear = gear;
                                    gearMap.set(gear.id, gear);
                                    gears.push(gear);
                                    workspaceContent.appendChild(gear.element);
                                }
                            }
                        });
                        
                        // Update all gear displays and styling
                        gears.forEach(gear => {
                            // Apply motor styling
                            if (gear.isMotor) {
                                gear.element.querySelector('.gear-circle').classList.add('motor-gear');
                            }
                            
                            // Apply pinned styling
                            if (gear.isPinned) {
                                gear.element.querySelector('.gear-circle').classList.add('pinned-gear');
                            }
                            
                            // Apply compound styling
                            if (gear.compoundGear || gear.parentGear) {
                                gear.element.querySelector('.gear-circle').classList.add('compound-gear');
                            }
                            
                            // Update compound layering
                            gear.updateCompoundLayering();
                            
                            // Update layer visibility
                            gear.updateLayerVisibility();
                            
                            // Update display
                            gear.updateDisplay();
                        });
                        
                        // Restore current layer
                        if (setupData.currentLayer !== undefined) {
                            currentLayer = setupData.currentLayer;
                            document.getElementById('layerSelect').value = currentLayer;
                            switchLayer(currentLayer);
                        }
                        
                        // Restore chains
                        if (setupData.chains && Array.isArray(setupData.chains)) {
                            setupData.chains.forEach(chainData => {
                                const gear1 = gearMap.get(chainData.gear1Id);
                                const gear2 = gearMap.get(chainData.gear2Id);
                                
                                if (gear1 && gear2) {
                                    const chain = new Chain(gear1, gear2);
                                    chain.id = chainData.id;
                                    
                                    // Update chain counter to avoid ID conflicts
                                    chainCounter = Math.max(chainCounter, chain.id);
                                    
                                    chains.push(chain);
                                    
                                    // Add chain references to gears
                                    gear1.chainConnections.push(chain);
                                    gear2.chainConnections.push(chain);
                                    
                                    // Add chain element to workspace
                                    workspaceContent.appendChild(chain.element);
                                }
                            });
                        }
                        
                        // Recalculate connections and physics
                        gears.forEach(gear => gear.findConnections());
                        calculateGearPhysics();
                        drawConnections();
                        updateChainPositions();
                        
                        showSuccessMessage("Gear setup loaded successfully! üìÅ");
                        
                    } catch (error) {
                        console.error('Error loading gear setup:', error);
                        showErrorMessage("Failed to load gear setup. Please check that the file is a valid gear setup file.");
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        function showSuccessMessage(message) {
            const popup = document.createElement('div');
            popup.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #10b981;
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 8px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                z-index: 10000;
                font-weight: 600;
                animation: slideIn 0.3s ease-out;
            `;
            popup.textContent = message;
            
            // Add animation keyframes
            if (!document.getElementById('toastStyles')) {
                const style = document.createElement('style');
                style.id = 'toastStyles';
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes slideOut {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(100%); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(popup);
            
            setTimeout(() => {
                popup.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => popup.remove(), 300);
            }, 3000);
        }
        
        function showErrorMessage(message) {
            const popup = document.createElement('div');
            popup.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #ef4444;
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 8px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                z-index: 10000;
                font-weight: 600;
                animation: slideIn 0.3s ease-out;
            `;
            popup.textContent = message;
            
            document.body.appendChild(popup);
            
            setTimeout(() => {
                popup.style.animation = 'slideOut 0.3s ease-in';
                setTimeout(() => popup.remove(), 300);
            }, 4000);
        }

        function showBackToHubConfirmation() {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay';
            
            // Create popup
            const popup = document.createElement('div');
            popup.className = 'confirmation-popup';
            popup.innerHTML = `
                <h3>üè† Return to Interactive Hub?</h3>
                <p>Are you sure you want to leave? Any unsaved gear designs will be lost.</p>
                <div class="button-group">
                    <button class="btn-cancel" onclick="closeBackToHubConfirmation()">Stay Here</button>
                    <button class="btn-confirm" onclick="goBackToHub()">Yes, Go Back</button>
                </div>
            `;
            
            document.body.appendChild(overlay);
            document.body.appendChild(popup);
            
            // Close on overlay click
            overlay.addEventListener('click', closeBackToHubConfirmation);
        }

        function closeBackToHubConfirmation() {
            const overlay = document.querySelector('.popup-overlay');
            const popup = document.querySelector('.confirmation-popup');
            
            if (overlay) overlay.remove();
            if (popup) popup.remove();
        }

        function goBackToHub() {
            // Navigate to the Interactive Hub
            window.open('https://engineeringshare.github.io/engineering-hub/interactive-hub/', '_self');
        }

        // Example gear setups
        const gearExamples = [
            {
                name: "Epicyclic Gear Example",
                description: "A planetary gear system with a pinned sun gear (red motor) surrounded by planet gears inside a ring gear. Demonstrates orbital motion and gear ratios in epicyclic systems.",
                data: {
                    "version": "1.0",
                    "timestamp": "2025-10-15T13:27:08.915Z",
                    "motorRPM": 120,
                    "currentLayer": 0,
                    "layers": [0, 1],
                    "maxLayer": 1,
                    "camera": { "x": 0, "y": 0, "zoom": 1 },
                    "gears": [
                        {
                            "id": 4,
                            "x": 607,
                            "y": 200,
                            "size": 80,
                            "isRingGear": false,
                            "isMotor": true,
                            "isPinned": true,
                            "layer": 0,
                            "parentGearId": null,
                            "compoundGearId": null,
                            "infoX": 382,
                            "infoY": 100
                        },
                        {
                            "id": 5,
                            "x": 608,
                            "y": 125,
                            "size": 80,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 0,
                            "parentGearId": null,
                            "compoundGearId": null,
                            "infoX": 301,
                            "infoY": -54
                        },
                        {
                            "id": 6,
                            "x": 607,
                            "y": 279,
                            "size": 80,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 0,
                            "parentGearId": null,
                            "compoundGearId": null,
                            "infoX": 166,
                            "infoY": 84
                        },
                        {
                            "id": 7,
                            "x": 503,
                            "y": 99,
                            "size": 280,
                            "isRingGear": true,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 0,
                            "parentGearId": null,
                            "compoundGearId": null,
                            "infoX": -280,
                            "infoY": -34
                        }
                    ],
                    "chains": []
                }
            },
            {
                name: "Chain Transmission Example",
                description: "Demonstrates chain transmission between gears across different layers. The motor gear drives a compound gear system via chain connection, showing how chains maintain rotation direction and transmit power over distance.",
                data: {
                    "version": "1.0",
                    "timestamp": "2025-10-16T14:27:33.043Z",
                    "motorRPM": 120,
                    "currentLayer": "all",
                    "layers": [0, 1],
                    "maxLayer": 1,
                    "camera": { "x": 258, "y": 104, "zoom": 0.8 },
                    "gears": [
                        {
                            "id": 1,
                            "x": 818.444295896682,
                            "y": 94,
                            "size": 80,
                            "isRingGear": false,
                            "isMotor": true,
                            "isPinned": false,
                            "layer": 0,
                            "parentGearId": null,
                            "compoundGearId": null,
                            "infoX": 100,
                            "infoY": 0
                        },
                        {
                            "id": 2,
                            "x": 344,
                            "y": 44,
                            "size": 240,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 0,
                            "parentGearId": null,
                            "compoundGearId": 3,
                            "infoX": -335,
                            "infoY": 33
                        },
                        {
                            "id": 3,
                            "x": 419,
                            "y": 119,
                            "size": 90,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 1,
                            "parentGearId": 2,
                            "compoundGearId": null,
                            "infoX": 110,
                            "infoY": 0
                        },
                        {
                            "id": 5,
                            "x": 235,
                            "y": -11,
                            "size": 210,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 1,
                            "parentGearId": null,
                            "compoundGearId": null,
                            "infoX": -249,
                            "infoY": -73
                        }
                    ],
                    "chains": [
                        {
                            "id": 1,
                            "gear1Id": 1,
                            "gear2Id": 2
                        }
                    ]
                }
            },
            {
                name: "Compound Gear Chain Example",
                description: "A complex multi-layer gear train featuring compound gears (orange) across 6 different layers. Each compound gear has two different sized gears on the same shaft, creating sophisticated gear ratios and mechanical advantage through the chain.",
                data: {
                    "version": "1.1",
                    "timestamp": "2025-10-17T14:44:01.643Z",
                    "motorRPM": 120,
                    "currentLayer": "all",
                    "layers": [0, 1, 2, 3, 4, 5, 6],
                    "maxLayer": 6,
                    "camera": { "x": 249, "y": 186, "zoom": 0.5 },
                    "gears": [
                        {
                            "id": 1,
                            "x": 742,
                            "y": 196,
                            "size": 80,
                            "isRingGear": false,
                            "isMotor": true,
                            "isPinned": false,
                            "layer": 6,
                            "parentGearId": null,
                            "compoundGearId": null,
                            "infoX": 100,
                            "infoY": 0
                        },
                        {
                            "id": 2,
                            "x": 580,
                            "y": 113,
                            "size": 240,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 5,
                            "parentGearId": null,
                            "compoundGearId": 3,
                            "infoX": 284,
                            "infoY": -195
                        },
                        {
                            "id": 4,
                            "x": 432,
                            "y": 181,
                            "size": 240,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 4,
                            "parentGearId": null,
                            "compoundGearId": 5,
                            "infoX": 229,
                            "infoY": -380
                        },
                        {
                            "id": 6,
                            "x": 268,
                            "y": 205,
                            "size": 240,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 3,
                            "parentGearId": null,
                            "compoundGearId": 7,
                            "infoX": 215,
                            "infoY": -385
                        },
                        {
                            "id": 8,
                            "x": 106,
                            "y": 186,
                            "size": 240,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 2,
                            "parentGearId": null,
                            "compoundGearId": 9,
                            "infoX": 179,
                            "infoY": -376
                        },
                        {
                            "id": 10,
                            "x": -34,
                            "y": 99,
                            "size": 240,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 1,
                            "parentGearId": null,
                            "compoundGearId": 11,
                            "infoX": 137,
                            "infoY": -293
                        },
                        {
                            "id": 3,
                            "x": 655,
                            "y": 188,
                            "size": 90,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 6,
                            "parentGearId": 2,
                            "compoundGearId": null,
                            "infoX": 110,
                            "infoY": 0
                        },
                        {
                            "id": 5,
                            "x": 507,
                            "y": 256,
                            "size": 90,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 5,
                            "parentGearId": 4,
                            "compoundGearId": null,
                            "infoX": 110,
                            "infoY": 0
                        },
                        {
                            "id": 7,
                            "x": 343,
                            "y": 280,
                            "size": 90,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 4,
                            "parentGearId": 6,
                            "compoundGearId": null,
                            "infoX": 110,
                            "infoY": 0
                        },
                        {
                            "id": 9,
                            "x": 181,
                            "y": 261,
                            "size": 90,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 3,
                            "parentGearId": 8,
                            "compoundGearId": null,
                            "infoX": 110,
                            "infoY": 0
                        },
                        {
                            "id": 11,
                            "x": 40,
                            "y": 174,
                            "size": 90,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 2,
                            "parentGearId": 10,
                            "compoundGearId": null,
                            "infoX": 110,
                            "infoY": 0
                        },
                        {
                            "id": 21,
                            "x": -61,
                            "y": 66,
                            "size": 80,
                            "isRingGear": false,
                            "isMotor": false,
                            "isPinned": false,
                            "layer": 1,
                            "parentGearId": null,
                            "compoundGearId": null,
                            "infoX": -114,
                            "infoY": -184
                        }
                    ],
                    "chains": []
                }
            }
        ];

        function showExamplesMenu() {
            if (isAnimating) {
                showWarningPopup("Please stop the animation before loading examples.");
                return;
            }

            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay';
            
            // Create popup
            const popup = document.createElement('div');
            popup.className = 'examples-popup';
            
            let examplesHTML = `
                <h3>üìö Load Example Gear Systems</h3>
                <div class="examples-list">
            `;
            
            gearExamples.forEach((example, index) => {
                examplesHTML += `
                    <div class="example-item" onclick="loadExample(${index})">
                        <div class="example-title">${example.name}</div>
                        <div class="example-description">${example.description}</div>
                    </div>
                `;
            });
            
            examplesHTML += `
                </div>
                <button class="close-btn" onclick="closeExamplesMenu()">Close</button>
            `;
            
            popup.innerHTML = examplesHTML;
            
            document.body.appendChild(overlay);
            document.body.appendChild(popup);
            
            // Close on overlay click
            overlay.addEventListener('click', closeExamplesMenu);
        }

        function closeExamplesMenu() {
            const overlay = document.querySelector('.popup-overlay');
            const popup = document.querySelector('.examples-popup');
            
            if (overlay) overlay.remove();
            if (popup) popup.remove();
        }

        function loadExample(exampleIndex) {
            if (exampleIndex < 0 || exampleIndex >= gearExamples.length) {
                showErrorMessage("Invalid example selection.");
                return;
            }

            const example = gearExamples[exampleIndex];
            
            try {
                // Close the examples menu
                closeExamplesMenu();
                
                // Clear current setup
                clearWorkspace();
                
                // Load the example data using the same logic as loadGearSetup
                const setupData = example.data;
                
                // Restore global settings
                if (setupData.motorRPM) {
                    motorRPM = setupData.motorRPM;
                    document.getElementById('rpmSlider').value = motorRPM;
                    document.getElementById('rpmValue').textContent = motorRPM;
                }
                
                if (setupData.layers) {
                    layers = [...setupData.layers];
                    maxLayer = setupData.maxLayer || Math.max(...layers);
                    updateLayerSelect();
                }
                
                if (setupData.camera) {
                    cameraX = setupData.camera.x || 0;
                    cameraY = setupData.camera.y || 0;
                    cameraZoom = setupData.camera.zoom || 1;
                    updateCamera();
                }
                
                // Restore gears in two passes to handle compound gear relationships
                const gearMap = new Map();
                const workspaceContent = document.getElementById('workspaceContent');
                
                // First pass: Create all regular gears and outer compound gears
                setupData.gears.forEach(gearData => {
                    if (!gearData.parentGearId) { // Skip inner compound gears for now
                        const gear = new Gear(
                            gearData.x,
                            gearData.y,
                            gearData.size,
                            gearData.isRingGear,
                            null, // No parent yet
                            gearData.layer
                        );
                        
                        // Restore properties
                        gear.id = gearData.id;
                        gear.isMotor = gearData.isMotor || false;
                        gear.isPinned = gearData.isPinned || false;
                        
                        // Update gear counter to avoid ID conflicts
                        gearCounter = Math.max(gearCounter, gear.id);
                        
                        gearMap.set(gear.id, gear);
                        gears.push(gear);
                        workspaceContent.appendChild(gear.element);
                        
                        // Restore info box position
                        const info = gear.element.querySelector('.gear-info');
                        if (info && gearData.infoX !== undefined && gearData.infoY !== undefined) {
                            info.style.left = gearData.infoX + 'px';
                            info.style.top = gearData.infoY + 'px';
                        }
                    }
                });
                
                // Second pass: Create inner compound gears and establish relationships
                setupData.gears.forEach(gearData => {
                    if (gearData.parentGearId) {
                        const parentGear = gearMap.get(gearData.parentGearId);
                        if (parentGear) {
                            const gear = new Gear(
                                gearData.x,
                                gearData.y,
                                gearData.size,
                                gearData.isRingGear,
                                parentGear,
                                gearData.layer
                            );
                            
                            gear.id = gearData.id;
                            gear.isMotor = gearData.isMotor || false;
                            gear.isPinned = gearData.isPinned || false;
                            
                            gearCounter = Math.max(gearCounter, gear.id);
                            
                            parentGear.compoundGear = gear;
                            gearMap.set(gear.id, gear);
                            gears.push(gear);
                            workspaceContent.appendChild(gear.element);
                        }
                    }
                });
                
                // Update all gear displays and styling
                gears.forEach(gear => {
                    // Apply motor styling
                    if (gear.isMotor) {
                        gear.element.querySelector('.gear-circle').classList.add('motor-gear');
                    }
                    
                    // Apply pinned styling
                    if (gear.isPinned) {
                        gear.element.querySelector('.gear-circle').classList.add('pinned-gear');
                    }
                    
                    // Apply compound styling
                    if (gear.compoundGear || gear.parentGear) {
                        gear.element.querySelector('.gear-circle').classList.add('compound-gear');
                    }
                    
                    // Update compound layering
                    gear.updateCompoundLayering();
                    
                    // Update layer visibility
                    gear.updateLayerVisibility();
                    
                    // Update display
                    gear.updateDisplay();
                });
                
                // Restore current layer
                if (setupData.currentLayer !== undefined) {
                    currentLayer = setupData.currentLayer;
                    document.getElementById('layerSelect').value = currentLayer;
                    switchLayer(currentLayer);
                }
                
                // Restore chains
                if (setupData.chains && Array.isArray(setupData.chains)) {
                    setupData.chains.forEach(chainData => {
                        const gear1 = gearMap.get(chainData.gear1Id);
                        const gear2 = gearMap.get(chainData.gear2Id);
                        
                        if (gear1 && gear2) {
                            const chain = new Chain(gear1, gear2);
                            chain.id = chainData.id;
                            
                            // Update chain counter to avoid ID conflicts
                            chainCounter = Math.max(chainCounter, chain.id);
                            
                            chains.push(chain);
                            
                            // Add chain references to gears
                            gear1.chainConnections.push(chain);
                            gear2.chainConnections.push(chain);
                            
                            // Add chain element to workspace
                            workspaceContent.appendChild(chain.element);
                        }
                    });
                }
                
                // Recalculate connections and physics
                gears.forEach(gear => gear.findConnections());
                calculateGearPhysics();
                drawConnections();
                updateChainPositions();
                
                showSuccessMessage(`${example.name} loaded successfully! üìö`);
                
            } catch (error) {
                console.error('Error loading example:', error);
                showErrorMessage("Failed to load example. Please try again.");
            }
        }

        window.addEventListener('load', () => {
            addGear();
            updateDebugInfo();
            updateCamera(); // Initialize camera
        });
    </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'99013321a6af220a',t:'MTc2MDcxODgyOC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>